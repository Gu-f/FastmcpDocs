---
title: 工具转换
sidebarTitle: 工具转换
description: 创建具有修改的架构、参数映射和自定义行为的增强工具变体。
icon: wand-magic-sparkles
---

import { VersionBadge } from '/snippets/version-badge.mdx'

<VersionBadge version="2.8.0" />

工具转换允许您从现有工具创建新的增强工具。这个强大功能使您能够针对不同上下文调整工具、简化复杂界面或添加自定义逻辑，而无需重复代码。

## 为什么要转换工具？

通常，现有工具*几乎*完美符合您的用例，但它可能存在以下问题：
- 描述令人困惑（或根本没有描述）。
- 参数名称或描述对于 LLM 不够直观（例如，使用 `q` 而不是 `query`）。
- 您希望从 LLM 中隐藏不必要的参数。
- 在调用原始工具之前需要输入验证。
- 需要修改或格式化工具的输出。

您可以**转换**工具以适应您的需求，而不是从头重写工具。

## 基本转换

创建转换工具的主要方法是使用 `Tool.from_tool()` 类方法。最简单的情况下，您可以使用它来更改工具的顶级元数据，如 `name`、`description` 或 `tags`。

在以下简单示例中，我们取一个通用的 `search` 工具，并调整其名称和描述，以帮助 LLM 客户端更好地理解其目的。

```python {13-21}
from fastmcp import FastMCP
from fastmcp.tools import Tool

mcp = FastMCP()

# 原始的通用工具
@mcp.tool
def search(query: str, category: str = "all") -> list[dict]:
    """在数据库中搜索项目。"""
    return database.search(query, category)

# 通过更改元数据创建更具有领域特定性的版本
product_search_tool = Tool.from_tool(
    search,
    name="find_products",
    description="""
        在电子商务目录中搜索产品。
        当客户询问查找特定物品、
        检查可用性或浏览产品类别时使用。
        """,
)

mcp.add_tool(product_search_tool)
```

<Tip>
当您转换工具时，原始工具仍然在服务器上注册。为了避免使用两个类似的工具混淆 LLM，您可以禁用原始工具：

```python
from fastmcp import FastMCP
from fastmcp.tools import Tool

mcp = FastMCP()

# 原始通用工具
@mcp.tool
def search(query: str, category: str = "all") -> list[dict]:
    ...

# 创建更具有领域特定性的版本
product_search_tool = Tool.from_tool(search, ...)
mcp.add_tool(product_search_tool)

# 禁用原始工具
search.disable()
```
</Tip>

现在，客户端看到一个名为 `find_products` 的工具，具有明确的领域特定目的和相关标签，尽管它仍然使用原始通用 `search` 函数的逻辑。

### 参数

`Tool.from_tool()` 类方法是创建转换工具的主要方法。它接受以下参数：

- `tool`：要转换的工具。这是唯一的必需参数。
- `name`：新工具的可选名称。
- `description`：新工具的可选描述。
- `transform_args`：`ArgTransform` 对象的字典，每个您想要修改的参数对应一个。
- `transform_fn`：一个可选函数，将被调用以替代父工具的逻辑。
- `output_schema`：控制输出架构和结构化输出（参见 [输出架构控制](#output-schema-control)）。
- `tags`：新工具的可选标签集。
- `annotations`：新工具的可选 `ToolAnnotations` 集。
- `serializer`：一个可选函数，将被调用来序列化新工具的结果。
- `meta`：控制工具的元信息。使用 `None` 来移除元信息，使用任何字典来设置元信息，或不设置以从父级继承。

结果是一个新的 `TransformedTool` 对象，它包装父工具并应用您指定的转换。您可以使用其 `add_tool()` 方法将此工具添加到您的 MCP 服务器。



## 修改参数

要修改工具的参数，请向 `Tool.from_tool()` 的 `transform_args` 参数提供 `ArgTransform` 对象的字典。每个键是您想要修改的*原始*参数的名称。

<Tip>
您只需要为您想要修改的参数提供 `transform_args` 条目。所有其他参数将保持不变地传递。
</Tip>

### ArgTransform 类

要修改参数，您需要创建一个 `ArgTransform` 对象。此对象具有以下参数：

- `name`：参数的新名称。
- `description`：参数的新描述。
- `default`：参数的新默认值。
- `default_factory`：一个函数，将被调用来为参数生成默认值。这对于需要为每次工具调用生成的参数（如时间戳或唯一 ID）很有用。
- `hide`：是否从 LLM 中隐藏参数。
- `required`：参数是否为必需，通常用于使可选参数变为必需参数。
- `type`：参数的新类型。

<Tip>
某些参数组合是不允许的。例如，您只能在 `hide=True` 时使用 `default_factory`，因为动态默认值无法在客户端的 JSON 架构中表示。您只能对未声明默认值的参数设置 required=True。
</Tip>


### 描述

在工具本身的描述之后，转换工具的最常见原因是改善其参数描述。好的描述对于帮助 LLM 理解如何正确使用参数至关重要。在包装来自外部 API 的工具时，这尤其重要，因为它们的参数描述可能缺失或是为开发人员而不是 LLM 编写的。

在此示例中，我们为 `user_id` 参数添加了有用的描述：

```python {16-19}
from fastmcp import FastMCP
from fastmcp.tools import Tool
from fastmcp.tools.tool_transform import ArgTransform

mcp = FastMCP()

@mcp.tool
def find_user(user_id: str):
    """根据 ID 查找用户。"""
    ...

new_tool = Tool.from_tool(
    find_user,
    transform_args={
        "user_id": ArgTransform(
            description=(
                "用户的唯一标识符，"
                "通常采用 'usr-xxxxxxxx' 格式。"
            )
        )
    }
)
```

### 名称

有时，您可能想要重命名参数，以使其对 LLM 更具直观性。

例如，在以下示例中，我们将通用的 `q` 参数扩展为 `search_query`：

```python {15}
from fastmcp import FastMCP
from fastmcp.tools import Tool
from fastmcp.tools.tool_transform import ArgTransform

mcp = FastMCP()

@mcp.tool
def search(q: str):
    """在数据库中搜索项目。"""
    return database.search(q)

new_tool = Tool.from_tool(
    search,
    transform_args={
        "q": ArgTransform(name="search_query")
    }
)
```

### 默认值

您可以使用 `default` 参数更新任何参数的默认值。在这里，我们将 `y` 参数的默认值更改为 10：

```python{15}
from fastmcp import FastMCP
from fastmcp.tools import Tool
from fastmcp.tools.tool_transform import ArgTransform

mcp = FastMCP()

@mcp.tool
def add(x: int, y: int) -> int:
    """将两个数字相加。"""
    return x + y

new_tool = Tool.from_tool(
    add,
    transform_args={
        "y": ArgTransform(default=10)
    }
)
```

默认值与隐藏参数结合使用特别有用。

### 隐藏参数

有时工具需要不应该向 LLM 暴露的参数，如 API 密钥、配置标志或内部 ID。您可以使用 `hide=True` 隐藏这些参数。请注意，您只能隐藏具有默认值的参数（或您提供新默认值的参数），因为 LLM 无法在调用时提供值。

<Tip>
要将常数值传递给父工具，请将 `hide=True` 与 `default=<value>` 结合使用。
</Tip>

```python {19-20}
import os
from fastmcp import FastMCP
from fastmcp.tools import Tool
from fastmcp.tools.tool_transform import ArgTransform

mcp = FastMCP()

@mcp.tool
def send_email(to: str, subject: str, body: str, api_key: str):
    """发送电子邮件。"""
    ...
    
# 创建一个隐藏 API 密钥的简化版本
new_tool = Tool.from_tool(
    send_email,
    name="send_notification",
    transform_args={
        "api_key": ArgTransform(
            hide=True, 
            default=os.environ.get("EMAIL_API_KEY"),
        )
    }
)
```
LLM 现在只看到 `to`、`subject` 和 `body` 参数。`api_key` 从环境变量自动提供。

对于必须为每次工具调用生成的值（如时间戳或唯一 ID），请使用 `default_factory`，它在每次调用工具时都会不带参数调用。例如，

```python {3-4}
transform_args = {
    'timestamp': ArgTransform(
        hide=True,
        default_factory=lambda: datetime.now(),
    )
}
```

<Warning>
`default_factory` 只能与 `hide=True` 一起使用。这是因为可见参数需要静态默认值，这些值可以在客户端的 JSON 架构中表示。
</Warning>

### 元信息

<VersionBadge version="2.11.0" />

您可以使用 `meta` 参数控制转换工具上的元信息。元信息是关于工具的附加数据，不影响其功能，但可以被客户端用于分类、路由或其他目的。

```python {15-17}
from fastmcp import FastMCP
from fastmcp.tools import Tool

mcp = FastMCP()

@mcp.tool
def analyze_data(data: str) -> dict:
    """分析提供的数据。"""
    return {"result": f"Analysis of {data}"}

# 添加自定义元信息
enhanced_tool = Tool.from_tool(
    analyze_data,
    name="enhanced_analyzer",
    meta={
        "category": "analytics",
        "priority": "high",
        "requires_auth": True
    }
)

mcp.add_tool(enhanced_tool)
```

您也可以完全移除元信息：

```python {6}
# 从父工具中移除元信息
simplified_tool = Tool.from_tool(
    analyze_data,
    name="simple_analyzer", 
    meta=None  # 移除任何元信息
)
```

如果您不指定 `meta` 参数，转换工具将继承父工具的元信息。

### 必需值

在您想要使可选参数变为必需参数的罕见情况下，您可以设置 `required=True`。如果参数已经是必需的，这没有影响。

```python {3}
transform_args = {
    'user_id': ArgTransform(
        required=True,
    )
}
```

## 修改工具行为

<Warning>
力量越大，责任越大。修改工具行为是一个非常高级的功能。
</Warning>

除了更改工具的架构外，高级用户还可以修改其行为。这对于添加验证逻辑或对工具的输出进行后处理很有用。

`from_tool()` 方法接受 `transform_fn` 参数，这是一个异步函数，它替换父工具的逻辑并给您对工具执行的完全控制。

### 转换函数

`transform_fn` 是一个异步函数，它**完全替换**父工具的逻辑。

至关重要的是，转换函数的参数用于确定新工具的最终架构。任何在父工具架构或 `transform_args` 中不存在的参数都将被添加到新工具的架构中。请注意，当 `transform_args` 和您的函数具有相同的参数名称时，如果提供了 `transform_args` 元数据，则它将优先。

```python
async def my_custom_logic(user_input: str, max_length: int = 100) -> str:
    # 您的自定义逻辑 - 这完全替换了父工具
    return f"自定义结果：{user_input[:max_length]}"

Tool.from_tool(transform_fn=my_custom_logic)
```

<Tip>
`transform_fn` 的名称/文档字符串被忽略。只有其参数用于确定最终架构。
</Tip>

### 调用父工具

大多数时候，您不希望完全替换父工具的行为。相反，您希望在仍然利用父工具核心功能的同时，添加验证、修改输入或后处理输出。为此，FastMCP 提供了特殊的 `forward()` 和 `forward_raw()` 函数。

`forward()` 和 `forward_raw()` 都是异步函数，它们允许您在 `transform_fn` 中调用父工具：

- **`forward()`**（推荐）：根据您的 `ArgTransform` 配置自动处理参数映射。使用转换后的参数名调用它。
- **`forward_raw()`**：绕过所有转换，直接使用原始参数名调用父工具。除非您进行复杂的参数操作（可能不使用 `arg_transforms`），否则很少需要。

最常见的转换模式是在调用父工具之前验证（可能重命名的）参数。这里是一个示例，在调用父工具之前验证 `x` 和 `y` 是否为正数：
<Tabs>
<Tab title="使用 forward()">

在最简单的情况下，您的父工具和转换函数具有相同的参数。您可以使用与父工具相同的参数名调用 `forward()`：

```python {15}
from fastmcp import FastMCP
from fastmcp.tools import Tool
from fastmcp.tools.tool_transform import forward

mcp = FastMCP()

@mcp.tool
def add(x: int, y: int) -> int:
    """将两个数字相加。"""
    return x + y

async def ensure_positive(x: int, y: int) -> int:
    if x <= 0 or y <= 0:
        raise ValueError("x 和 y 必须为正数")
    return await forward(x=x, y=y)

new_tool = Tool.from_tool(
    add,
    transform_fn=ensure_positive,
)

mcp.add_tool(new_tool)
```
</Tab>
<Tab title="在重命名参数时使用 forward()">

当您的转换工具与父工具具有不同的参数名时，您可以使用重命名的参数调用 `forward()`，它将自动将参数映射到父工具的参数：

```python {15, 20-23}
from fastmcp import FastMCP
from fastmcp.tools import Tool
from fastmcp.tools.tool_transform import forward

mcp = FastMCP()

@mcp.tool
def add(x: int, y: int) -> int:
    """将两个数字相加。"""
    return x + y

async def ensure_positive(a: int, b: int) -> int:
    if a <= 0 or b <= 0:
        raise ValueError("a 和 b 必须为正数。")
    return await forward(a=a, b=b)

new_tool = Tool.from_tool(
    add,
    transform_fn=ensure_positive,
    transform_args={
        "x": ArgTransform(name="a"),
        "y": ArgTransform(name="b"),
    }
)

mcp.add_tool(new_tool)
```
</Tab>
<Tab title="使用 forward_raw()">
最后，您可以使用 `forward_raw()` 绕过所有参数映射，直接使用原始参数名调用父工具。

```python {15, 20-23}
from fastmcp import FastMCP
from fastmcp.tools import Tool
from fastmcp.tools.tool_transform import forward

mcp = FastMCP()

@mcp.tool
def add(x: int, y: int) -> int:
    """将两个数字相加。"""
    return x + y

async def ensure_positive(a: int, b: int) -> int:
    if a <= 0 or b <= 0:
        raise ValueError("a 和 b 必须为正数")
    return await forward_raw(x=a, y=b)

new_tool = Tool.from_tool(
    add,
    transform_fn=ensure_positive,
    transform_args={
        "x": ArgTransform(name="a"),
        "y": ArgTransform(name="b"),
    }
)

mcp.add_tool(new_tool)
```
</Tab>
</Tabs>

### 使用 **kwargs 传递参数

如果您的 `transform_fn` 在其签名中包含 `**kwargs`，它将在应用 `ArgTransform` 配置后**接收来自父工具的所有参数**。这对于创建灵活的验证函数很有用，无需将每个参数都添加到函数签名中。

在以下示例中，我们包装一个接受两个参数 `x` 和 `y` 的父工具。在转换工具中，它们被重命名为 `a` 和 `b`，转换只验证 `a`，将其他参数作为 `**kwargs` 传递。

```python {12, 15}
from fastmcp import FastMCP
from fastmcp.tools import Tool
from fastmcp.tools.tool_transform import forward

mcp = FastMCP()

@mcp.tool
def add(x: int, y: int) -> int:
    """将两个数字相加。"""
    return x + y

async def ensure_a_positive(a: int, **kwargs) -> int:
    if a <= 0:
        raise ValueError("a 必须为正数")
    return await forward(a=a, **kwargs)

new_tool = Tool.from_tool(
    add,
    transform_fn=ensure_a_positive,
    transform_args={
        "x": ArgTransform(name="a"),
        "y": ArgTransform(name="b"),
    }
)

mcp.add_tool(new_tool)
```

<Tip>
在上面的示例中，`**kwargs` 接收重命名的参数 `b`，而不是原始参数 `y`。因此建议与 `forward()` 一起使用，而不是 `forward_raw()`。
</Tip>

## 使用 MCPConfig 修改 MCP 工具

在 FastMCP 下使用 `MCPConfig` 运行 MCP 服务器时，您还可以直接在 MCPConfig json 文件中应用工具转换的子集。

```json
{
    "mcpServers": {
        "weather": {
            "url": "https://weather.example.com/mcp",
            "transport": "http",
            "tools": {
                "weather_get_forecast": {
                    "name": "miami_weather",
                    "description": "获取迈阿密的天气",
                    "meta": {
                        "category": "weather",
                        "location": "miami"
                    },
                    "arguments": {
                        "city": {
                            "name": "city",
                            "default": "Miami",
                            "hide": True,
                        }
                    }
                }
            }
        }
    }
}
```

`tools` 部分是工具名称到工具配置的字典。每个工具配置是工具属性的字典。

有关更多详细信息，请参见 [MCPConfigTransport](/zh/clients/transports#tool-transformation-with-fastmcp-and-mcpconfig) 文档。


## 输出架构控制

<VersionBadge version="2.10.0" />

转换工具默认从其父级继承输出架构，但您可以控制此行为：

**从父级继承（默认）**
```python
Tool.from_tool(parent_tool, name="renamed_tool")
```
转换工具自动使用父工具的输出架构和结构化输出行为。

**自定义输出架构**
```python
Tool.from_tool(parent_tool, output_schema={
    "type": "object", 
    "properties": {"status": {"type": "string"}}
})
```
提供与父级不同的自己的架构。工具必须返回与此架构匹配的数据。

**移除输出架构**
```python
Tool.from_tool(parent_tool, output_schema=False)
```
移除输出架构声明。自动结构化内容仍然适用于类对象返回（dict、dataclass、Pydantic 模型），但原始类型不会被结构化。

**使用转换函数的完全控制**
```python
async def custom_output(**kwargs) -> ToolResult:
    result = await forward(**kwargs)
    return ToolResult(content=[...], structured_content={...})

Tool.from_tool(parent_tool, transform_fn=custom_output)
```
使用返回 `ToolResult` 的转换函数来对内容块和结构化输出进行完全控制。

## 常见模式

工具转换是一个灵活的功能，支持许多强大的模式。以下是一些常见用例，给您一些想法。

### 适配远程或生成的工具
这是使用工具转换的最常见原因之一。来自远程服务器（通过 [代理](/zh/servers/proxy)）或从 [OpenAPI 规范](/zh/integrations/openapi) 生成的工具通常太通用，无法直接被 LLM 使用。您可以使用转换为您的特定需求创建更简单、更直观的版本。

### 链式转换
您可以通过使用已转换的工具作为新转换的父级来链接转换。这让您可以分层构建复杂的行为，例如，首先重命名参数，然后向重命名的工具添加验证逻辑。

### 上下文感知工具工厂
您可以编写作为“工厂”的函数，为不同上下文生成工具的专用版本。例如，您可以通过隐藏 `user_id` 参数并自动提供它来创建一个特定于当前登录用户的 `get_my_data` 工具。
