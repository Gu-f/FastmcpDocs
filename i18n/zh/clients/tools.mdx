---
title: 工具操作
sidebarTitle: 工具
description: 使用 FastMCP 客户端发现和执行服务器端工具。
icon: wrench
---

import { VersionBadge } from '/snippets/version-badge.mdx'

<VersionBadge version="2.0.0" />

工具是 MCP 服务器公开的可执行函数。FastMCP 客户端提供了发现可用工具和使用参数执行它们的方法。

## 发现工具

使用 `list_tools()` 检索服务器上所有可用的工具：

```python
async with client:
    tools = await client.list_tools()
    # tools -> list[mcp.types.Tool]
    
    for tool in tools:
        print(f"工具: {tool.name}")
        print(f"描述: {tool.description}")
        if tool.inputSchema:
            print(f"参数: {tool.inputSchema}")
        # 访问标签和其他元数据
        if hasattr(tool, '_meta') and tool._meta:
            fastmcp_meta = tool._meta.get('_fastmcp', {})
            print(f"标签: {fastmcp_meta.get('tags', [])}")
```

### 按标签筛选

<VersionBadge version="2.11.0" />

您可以使用 `meta` 字段根据标签筛选工具：

```python
async with client:
    tools = await client.list_tools()
    
    # 按标签筛选工具
    analysis_tools = [
        tool for tool in tools 
        if hasattr(tool, '_meta') and tool._meta and
           tool._meta.get('_fastmcp', {}) and
           'analysis' in tool._meta.get('_fastmcp', {}).get('tags', [])
    ]
    
    print(f"找到 {len(analysis_tools)} 个分析工具")
```

<Note>
`_meta` 字段是标准 MCP 规范的一部分。FastMCP 服务器在 `_fastmcp` 命名空间内包含标签和其他元数据（例如 `_meta._fastmcp.tags`）以避免与用户定义的元数据冲突。这种行为可以通过服务器的 `include_fastmcp_meta` 设置控制 - 如果禁用，将不会包含 `_fastmcp` 命名空间。其他 MCP 服务器实现可能不提供此元数据结构。
</Note>

## 执行工具

### 基本执行

使用 `call_tool()` 和工具名称和参数执行工具：

```python
async with client:
    # 简单工具调用
    result = await client.call_tool("add", {"a": 5, "b": 3})
    # result -> 包含结构化和非结构化数据的 CallToolResult
    
    # 访问结构化数据（自动反序列化）
    print(result.data)  # 8 (int) 或原始类型的 {"result": 8}
    
    # 访问传统内容块  
    print(result.content[0].text)  # "8" (TextContent)
```

### 高级执行选项

`call_tool()` 方法支持用于超时控制和进度监控的附加参数：

```python
async with client:
    # 带超时（如果执行超过 2 秒则中止）
    result = await client.call_tool(
        "long_running_task", 
        {"param": "value"}, 
        timeout=2.0
    )
    
    # 带进度处理程序（跟踪执行进度）
    result = await client.call_tool(
        "long_running_task",
        {"param": "value"},
        progress_handler=my_progress_handler
    )
```

**参数：**
- `name`：工具名称（字符串）
- `arguments`：传递给工具的参数字典（可选）
- `timeout`：最大执行时间（秒）（可选，覆盖客户端级超时）
- `progress_handler`：进度回调函数（可选，覆盖客户端级处理程序）

## 处理结果

<VersionBadge version="2.10.0" />

工具执行返回一个包含结构化和传统内容的 `CallToolResult` 对象。FastMCP 的突出特性是 `.data` 属性，它不仅仅提供原始 JSON，而是实际充实完整的 Python 对象，包括日期时间、UUID 和自定义类等复杂类型。

### CallToolResult 属性

<Card icon="code" title="CallToolResult 属性">
<ResponseField name=".data" type="Any">
  **FastMCP 独有**：支持复杂类型（日期时间、UUID、自定义类）的完全充实 Python 对象。超越 JSON 提供从输出模式完整重建对象。
</ResponseField>

<ResponseField name=".content" type="list[mcp.types.ContentBlock]">
  所有 MCP 服务器都可用的标准 MCP 内容块（`TextContent`、`ImageContent`、`AudioContent` 等）。
</ResponseField>

<ResponseField name=".structured_content" type="dict[str, Any] | None">
  服务器发送的标准 MCP 结构化 JSON 数据，支持结构化输出的所有 MCP 服务器都可用。
</ResponseField>

<ResponseField name=".is_error" type="bool">
  指示工具执行是否失败的布尔值。
</ResponseField>
</Card>

### 结构化数据访问

FastMCP 的 `.data` 属性提供完全充实的 Python 对象，而不仅仅是 JSON 字典。这包括复杂类型重建：

```python
from datetime import datetime
from uuid import UUID

async with client:
    result = await client.call_tool("get_weather", {"city": "London"})
    
    # FastMCP 从服务器的输出模式重建完整的 Python 对象
    weather = result.data  # 服务器定义的 WeatherReport 对象
    print(f"温度: {weather.temperature}°C 于 {weather.timestamp}")
    print(f"站点: {weather.station_id}")
    print(f"湿度: {weather.humidity}%")
    
    # 时间戳是真实的 datetime 对象，不是字符串！
    assert isinstance(weather.timestamp, datetime)
    assert isinstance(weather.station_id, UUID)
    
    # 与原始结构化 JSON（标准 MCP）比较
    print(f"原始 JSON: {result.structured_content}")
    # {"temperature": 20, "timestamp": "2024-01-15T14:30:00Z", "station_id": "123e4567-..."}
    
    # 传统内容块（标准 MCP）  
    print(f"文本内容: {result.content[0].text}")
```

### 回退行为

对于没有输出模式的工具或当反序列化失败时，`.data` 将为 `None`：

```python
async with client:
    result = await client.call_tool("legacy_tool", {"param": "value"})
    
    if result.data is not None:
        # 结构化输出可用并成功反序列化
        print(f"结构化: {result.data}")
    else:
        # 没有结构化输出或反序列化失败 - 使用内容块
        for content in result.content:
            if hasattr(content, 'text'):
                print(f"文本结果: {content.text}")
            elif hasattr(content, 'data'):
                print(f"二进制数据: {len(content.data)} 字节")
```

### 原始类型解包

<Tip>
FastMCP 服务器自动将非对象结果（如 `int`、`str`、`bool`）包装在 `{"result": value}` 结构中以创建有效的结构化输出。FastMCP 客户端理解这个约定并为了方便在 `.data` 中自动解包值，因此您获得的是原始原始值而不是包装对象。
</Tip>

```python
async with client:
    result = await client.call_tool("calculate_sum", {"a": 5, "b": 3})
    
    # FastMCP 客户端为了方便自动解包
    print(result.data)  # 8 (int) - 原始值
    
    # 原始结构化内容显示服务器端包装
    print(result.structured_content)  # {"result": 8}
    
    # 其他 MCP 客户端需要手动访问 ["result"]
    # value = result.structured_content["result"]  # FastMCP 不需要！
```

## 错误处理

### 基于异常的错误处理

默认情况下，如果工具执行失败，`call_tool()` 会引发 `ToolError`：

```python
from fastmcp.exceptions import ToolError

async with client:
    try:
        result = await client.call_tool("potentially_failing_tool", {"param": "value"})
        print("工具成功:", result.data)
    except ToolError as e:
        print(f"工具失败: {e}")
```

### 手动错误检查

您可以禁用自动错误引发并手动检查结果：

```python
async with client:
    result = await client.call_tool(
        "potentially_failing_tool", 
        {"param": "value"}, 
        raise_on_error=False
    )
    
    if result.is_error:
        print(f"工具失败: {result.content[0].text}")
    else:
        print(f"工具成功: {result.data}")
```

### 原始 MCP 协议访问

要获得完全控制，请使用返回原始 MCP 协议对象的 `call_tool_mcp()`：

```python
async with client:
    result = await client.call_tool_mcp("potentially_failing_tool", {"param": "value"})
    # result -> mcp.types.CallToolResult
    
    if result.isError:
        print(f"工具失败: {result.content}")
    else:
        print(f"工具成功: {result.content}")
        # 注意：call_tool_mcp() 不会自动反序列化
```

## 参数处理

参数作为字典传递给工具：

```python
async with client:
    # 简单参数
    result = await client.call_tool("greet", {"name": "World"})
    
    # 复杂参数
    result = await client.call_tool("process_data", {
        "config": {"format": "json", "validate": True},
        "items": [1, 2, 3, 4, 5],
        "metadata": {"source": "api", "version": "1.0"}
    })
```

<Tip>
对于多服务器客户端，工具名称会自动以服务器名称为前缀（例如，`weather` 服务器上名为 `get_forecast` 的工具会变为 `weather_get_forecast`）。
</Tip>