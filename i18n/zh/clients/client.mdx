---
title: FastMCP 客户端
sidebarTitle: 概述
description: 通过类型良好的 Pythonic 接口与 MCP 服务器交互的程序化客户端。
icon: user-robot
---

import { VersionBadge } from '/snippets/version-badge.mdx'

<VersionBadge version="2.0.0" />

MCP 客户端应用程序的核心部分是 `fastmcp.Client` 类。该类提供了一个**程序化接口**，用于与任何模型上下文协议 (MCP) 服务器交互，自动处理协议细节和连接管理。

FastMCP 客户端专为确定性的受控交互而设计，而非自主行为，这使其非常适合：

- **在开发过程中测试 MCP 服务器**
- **构建需要可靠 MCP 交互的确定性应用程序**  
- **为智能体或基于 LLM 的客户端创建基础**，提供结构化的类型安全操作

所有客户端操作都需要使用 `async with` 上下文管理器来正确管理连接生命周期。


<Note>
这不是一个智能体客户端 - 它需要显式的函数调用，并提供对所有 MCP 操作的直接控制。将其用作高级系统的构建块。
</Note>

## 创建客户端

创建客户端很简单。您提供服务器源，客户端会自动推断合适的传输机制。

```python
import asyncio
from fastmcp import Client, FastMCP

# 内存服务器（非常适合测试）
server = FastMCP("TestServer")
client = Client(server)

# HTTP 服务器
client = Client("https://example.com/mcp")

# 本地 Python 脚本
client = Client("my_mcp_server.py")

async def main():
    async with client:
        # 基本服务器交互
        await client.ping()
        
        # 列出可用操作
        tools = await client.list_tools()
        resources = await client.list_resources()
        prompts = await client.list_prompts()
        
        # 执行操作
        result = await client.call_tool("example_tool", {"param": "value"})
        print(result)

asyncio.run(main())
```

## 客户端-传输架构

FastMCP 客户端将协议和连接的关注点分离：

- **`Client`**：处理 MCP 协议操作（工具、资源、提示）并管理回调
- **`Transport`**：建立和维护连接（WebSockets、HTTP、Stdio、内存）

### 传输推断

客户端根据输入自动推断合适的传输方式：

1. **`FastMCP` 实例** → 内存传输（非常适合测试）
2. **以 `.py` 结尾的文件路径** → Python Stdio 传输
3. **以 `.js` 结尾的文件路径** → Node.js Stdio 传输  
4. **以 `http://` 或 `https://` 开头的 URL** → HTTP 传输
5. **`MCPConfig` 字典** → 多服务器客户端

```python
from fastmcp import Client, FastMCP

# 传输推断示例
client_memory = Client(FastMCP("TestServer"))
client_script = Client("./server.py") 
client_http = Client("https://api.example.com/mcp")
```

<Tip>
对于测试和开发，始终建议通过将 `FastMCP` 服务器直接传递给客户端来优先使用内存传输。这消除了网络复杂性和单独进程。
</Tip>

## 基于配置的客户端

<VersionBadge version="2.4.0" />

从 MCP 配置字典创建客户端，可以包含多个服务器。虽然 MCP 配置格式没有官方标准，FastMCP 遵循 Claude Desktop 等工具使用的既定惯例。

### 配置格式

```python
config = {
    "mcpServers": {
        "server_name": {
            # 远程 HTTP/SSE 服务器
            "transport": "http",  # 或 "sse" 
            "url": "https://api.example.com/mcp",
            "headers": {"Authorization": "Bearer token"},
            "auth": "oauth"  # 或 bearer token 字符串
        },
        "local_server": {
            # 本地 stdio 服务器
            "transport": "stdio",
            "command": "python",
            "args": ["./server.py", "--verbose"],
            "env": {"DEBUG": "true"},
            "cwd": "/path/to/server",
        }
    }
}
```

### 多服务器示例

```python
config = {
    "mcpServers": {
        "weather": {"url": "https://weather-api.example.com/mcp"},
        "assistant": {"command": "python", "args": ["./assistant_server.py"]}
    }
}

client = Client(config)

async with client:
    # 工具使用服务器名称前缀
    weather_data = await client.call_tool("weather_get_forecast", {"city": "London"})
    response = await client.call_tool("assistant_answer_question", {"question": "What's the capital of France?"})
    
    # 资源使用前缀 URI
    icons = await client.read_resource("weather://weather/icons/sunny")
    templates = await client.read_resource("resource://assistant/templates/list")
```

## 连接生命周期

客户端异步运行，并使用上下文管理器进行连接管理：

```python
async def example():
    client = Client("my_mcp_server.py")
    
    # 连接在此建立
    async with client:
        print(f"Connected: {client.is_connected()}")
        
        # 在同一会话中进行多次调用
        tools = await client.list_tools()
        result = await client.call_tool("greet", {"name": "World"})
        
    # 连接在此自动关闭
    print(f"Connected: {client.is_connected()}")
```

## 操作

FastMCP 客户端可以与多种类型的服务器组件交互：

### 工具

工具是客户端可以使用参数执行的服务器端函数。

```python
async with client:
    # 列出可用工具
    tools = await client.list_tools()
    
    # 执行工具
    result = await client.call_tool("multiply", {"a": 5, "b": 3})
    print(result.data)  # 15
```

See [Tools](/zh/clients/tools) for detailed documentation.

### 资源

资源是客户端可以读取的数据源，可以是静态的或模板化的。

```python
async with client:
    # 列出可用资源
    resources = await client.list_resources()
    
    # 读取资源
    content = await client.read_resource("file:///config/settings.json")
    print(content[0].text)
```

See [Resources](/zh/clients/resources) for detailed documentation.

### 提示

提示是可以接受参数的可重用消息模板。

```python
async with client:
    # 列出可用提示
    prompts = await client.list_prompts()
    
    # 获取渲染的提示
    messages = await client.get_prompt("analyze_data", {"data": [1, 2, 3]})
    print(messages.messages)
```

See [Prompts](/zh/clients/prompts) for detailed documentation.

### 服务器连接性

使用 `ping()` 验证服务器是否可达：

```python
async with client:
    await client.ping()
    print("服务器可达")
```

## 客户端配置

可以为特殊用例配置客户端的附加处理程序和设置。

### 回调处理程序

客户端支持多个回调处理程序用于高级服务器交互：

```python
from fastmcp import Client
from fastmcp.client.logging import LogMessage

async def log_handler(message: LogMessage):
    print(f"服务器日志: {message.data}")

async def progress_handler(progress: float, total: float | None, message: str | None):
    print(f"进度: {progress}/{total} - {message}")

async def sampling_handler(messages, params, context):
    # 在此集成您的 LLM 服务
    return "生成的响应"

client = Client(
    "my_mcp_server.py",
    log_handler=log_handler,
    progress_handler=progress_handler,
    sampling_handler=sampling_handler,
    timeout=30.0
)
```

`Client` 构造函数接受多个配置选项：

- `transport`：传输实例或用于自动推断的源  
- `log_handler`：处理服务器日志消息
- `progress_handler`：监控长时间运行的操作
- `sampling_handler`：响应服务器 LLM 请求
- `roots`：为服务器提供本地上下文
- `timeout`：请求的默认超时时间（秒）

### 传输配置

有关详细的传输配置（标头、身份验证、环境变量），请参阅 [传输](/zh/clients/transports) 文档。

## 下一步

探索每种操作类型的详细文档：

### 核心操作
- **[工具](/zh/clients/tools)** - 执行服务器端函数并处理结果
- **[资源](/zh/clients/resources)** - 访问静态和模板化资源
- **[提示](/zh/clients/prompts)** - 使用消息模板和参数序列化

### 高级功能
- **[日志记录](/zh/clients/logging)** - 处理服务器日志消息
- **[进度](/zh/clients/progress)** - 监控长时间运行的操作
- **[采样](/zh/clients/sampling)** - 响应服务器 LLM 请求
- **[根](/zh/clients/roots)** - 为服务器提供本地上下文

### 连接详情
- **[传输](/zh/clients/transports)** - 配置连接方法和参数
- **[身份验证](/zh/clients/auth/oauth)** - 设置 OAuth 和 bearer token 身份验证

<Tip>
FastMCP 客户端设计为基础工具。可以直接用于确定性操作，或在其可靠、类型安全的接口上构建更高级的智能体系统。
</Tip>