---
title: 提示(Prompts)
sidebarTitle: 提示(Prompts)
description: 使用带有自动参数序列化的服务器端提示模板。
icon: message-lines
---

import { VersionBadge } from '/snippets/version-badge.mdx'

<VersionBadge version="2.0.0" />

提示是由 MCP 服务器公开的可重用消息模板。它们可以接受参数来为 LLM 交互生成个性化的消息序列。

## 列出提示

使用 `list_prompts()` 检索所有可用的提示模板：

```python
async with client:
    prompts = await client.list_prompts()
    # prompts -> list[mcp.types.Prompt]
    
    for prompt in prompts:
        print(f"提示: {prompt.name}")
        print(f"描述: {prompt.description}")
        if prompt.arguments:
            print(f"参数: {[arg.name for arg in prompt.arguments]}")
        # 访问标签和其他元数据
        if hasattr(prompt, '_meta') and prompt._meta:
            fastmcp_meta = prompt._meta.get('_fastmcp', {})
            print(f"标签: {fastmcp_meta.get('tags', [])}")
```

### 按标签筛选

<VersionBadge version="2.11.0" />

您可以使用 `meta` 字段根据标签筛选提示：

```python
async with client:
    prompts = await client.list_prompts()
    
    # 按标签筛选提示
    analysis_prompts = [
        prompt for prompt in prompts 
        if hasattr(prompt, '_meta') and prompt._meta and
           prompt._meta.get('_fastmcp', {}) and
           'analysis' in prompt._meta.get('_fastmcp', {}).get('tags', [])
    ]
    
    print(f"找到 {len(analysis_prompts)} 个分析提示")
```

<Note>
`_meta` 字段是标准 MCP 规范的一部分。FastMCP 服务器在 `_fastmcp` 命名空间内包含标签和其他元数据（例如 `_meta._fastmcp.tags`）以避免与用户定义的元数据冲突。这种行为可以通过服务器的 `include_fastmcp_meta` 设置控制 - 如果禁用，将不会包含 `_fastmcp` 命名空间。其他 MCP 服务器实现可能不提供此元数据结构。
</Note>

## 使用提示

### 基本用法

使用 `get_prompt()` 和提示名称和参数请求渲染的提示：

```python
async with client:
    # 不带参数的简单提示
    result = await client.get_prompt("welcome_message")
    # result -> mcp.types.GetPromptResult
    
    # 访问生成的消息
    for message in result.messages:
        print(f"角色: {message.role}")
        print(f"内容: {message.content}")
```

### 带参数的提示

将参数作为字典传递以自定义提示：

```python
async with client:
    # 带简单参数的提示
    result = await client.get_prompt("user_greeting", {
        "name": "Alice",
        "role": "administrator"
    })
    
    # 访问个性化消息
    for message in result.messages:
        print(f"生成的消息: {message.content}")
```

## 自动参数序列化

<VersionBadge version="2.9.0" />

FastMCP 按照 MCP 规范的要求自动将复杂参数序列化为 JSON 字符串。这允许您直接传递类型化对象：

```python
from dataclasses import dataclass

@dataclass
class UserData:
    name: str
    age: int

async with client:
    # 复杂参数会被自动序列化
    result = await client.get_prompt("analyze_user", {
        "user": UserData(name="Alice", age=30),     # 自动序列化为 JSON
        "preferences": {"theme": "dark"},           # 字典序列化为 JSON 字符串
        "scores": [85, 92, 78],                     # 列表序列化为 JSON 字符串
        "simple_name": "Bob"                        # 字符串保持不变
    })
```

客户端使用 `pydantic_core.to_json()` 处理序列化以实现一致的格式化。FastMCP 服务器可以自动将这些 JSON 字符串反序列化为预期类型。

### 序列化示例

```python
async with client:
    result = await client.get_prompt("data_analysis", {
        # 这些将被自动序列化为 JSON 字符串：
        "config": {
            "format": "csv",
            "include_headers": True,
            "delimiter": ","
        },
        "filters": [
            {"field": "age", "operator": ">", "value": 18},
            {"field": "status", "operator": "==", "value": "active"}
        ],
        # 这仍然是字符串：
        "report_title": "Monthly Analytics Report"
    })
```

## 处理提示结果

`get_prompt()` 方法返回一个包含消息列表的 `GetPromptResult` 对象：

```python
async with client:
    result = await client.get_prompt("conversation_starter", {"topic": "climate"})
    
    # 访问单个消息
    for i, message in enumerate(result.messages):
        print(f"消息 {i + 1}:")
        print(f"  角色: {message.role}")
        print(f"  内容: {message.content.text if hasattr(message.content, 'text') else message.content}")
```

## 原始 MCP 协议访问

要访问完整的 MCP 协议对象，请使用 `*_mcp` 方法：

```python
async with client:
    # 原始 MCP 方法返回完整的协议对象
    prompts_result = await client.list_prompts_mcp()
    # prompts_result -> mcp.types.ListPromptsResult
    
    prompt_result = await client.get_prompt_mcp("example_prompt", {"arg": "value"})
    # prompt_result -> mcp.types.GetPromptResult
```

## 多服务器客户端

使用多服务器客户端时，提示可以直接访问而不需前缀（与工具不同）：

```python
async with client:  # Multi-server client
    # 来自任何服务器的提示都可以直接访问
    result1 = await client.get_prompt("weather_prompt", {"city": "London"})
    result2 = await client.get_prompt("assistant_prompt", {"query": "help"})
```

## 常见提示模式

### 系统消息

许多提示为 LLM 配置生成系统消息：

```python
async with client:
    result = await client.get_prompt("system_configuration", {
        "role": "helpful assistant",
        "expertise": "python programming"
    })
    
    # 通常返回 role="system" 的消息
    system_message = result.messages[0]
    print(f"系统提示: {system_message.content}")
```

### 对话模板

提示可以生成多轮对话模板：

```python
async with client:
    result = await client.get_prompt("interview_template", {
        "candidate_name": "Alice",
        "position": "Senior Developer"
    })
    
    # 对话流的多个消息
    for message in result.messages:
        print(f"{message.role}: {message.content}")
```

<Tip>
提示参数及其预期类型取决于特定的提示实现。请查看服务器的文档或使用 `list_prompts()` 查看每个提示的可用参数。
</Tip>