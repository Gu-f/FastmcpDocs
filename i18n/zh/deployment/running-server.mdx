---
title: 运行您的服务器
sidebarTitle: 运行
description: 学习如何在本地运行您的 FastMCP 服务器进行开发和测试
icon: circle-play
---

FastMCP 服务器可以根据您的需求以不同方式运行。本指南专注于在本地运行服务器进行开发和测试。有关生产部署到 URL 的信息，请参阅[自托管部署](/zh/deployment/self-hosted)指南。

## `run()` 方法

每个 FastMCP 服务器都需要启动才能接受连接。运行服务器的最简单方法是在您的 FastMCP 实例上调用 `run()` 方法。此方法启动服务器并阻塞直到停止，为您处理所有连接管理。

<Tip>
为了获得最大兼容性，最佳实践是将 `run()` 调用放在 `if __name__ == "__main__":` 块中。这确保服务器仅在脚本直接执行时启动，而不是在作为模块导入时启动。
</Tip>

```python {9-10} my_server.py
from fastmcp import FastMCP

mcp = FastMCP(name="MyServer")

@mcp.tool
def hello(name: str) -> str:
    return f"Hello, {name}!"

if __name__ == "__main__":
    mcp.run()
```

您现在可以通过执行 `python my_server.py` 来运行此 MCP 服务器。

## 传输协议

MCP 服务器通过不同的传输协议与客户端通信。可以将传输协议视为您的服务器与客户端通信时使用的"语言"。FastMCP 支持三种主要传输协议，每种都专为特定用例和部署场景而设计。

传输协议的选择决定了客户端如何连接到您的服务器、有哪些网络功能可用，以及有多少客户端可以同时连接。了解这些传输协议有助于您为应用程序选择正确的方法。

### STDIO 传输（默认）

STDIO（标准输入/输出）是 FastMCP 服务器的默认传输协议。当您不带参数调用 `run()` 时，您的服务器使用 STDIO 传输。此传输协议通过标准输入和输出流进行通信，使其非常适合命令行工具和桌面应用程序（如 Claude Desktop）。

使用 STDIO 传输时，客户端为每个会话生成一个新的服务器进程并管理其生命周期。服务器从 stdin 读取 MCP 消息并将响应写入 stdout。这就是为什么 STDIO 服务器不会持续运行 - 它们由客户端按需启动。

```python
from fastmcp import FastMCP

mcp = FastMCP("MyServer")

@mcp.tool
def hello(name: str) -> str:
    return f"Hello, {name}!"

if __name__ == "__main__":
    mcp.run()  # 默认情况下使用 STDIO 传输方式
```

STDIO 的理想用途：
- 本地开发和测试
- Claude Desktop 集成
- 命令行工具
- 单用户应用程序

### HTTP 传输（流式）

HTTP 传输将您的 MCP 服务器转换为可通过 URL 访问的 Web 服务。此传输使用流式 HTTP 协议，允许客户端通过网络连接。与每个客户端获得自己进程的 STDIO 不同，HTTP 服务器可以同时处理多个客户端。

流式 HTTP 协议提供了客户端和服务器之间的完全双向通信，支持包括流式响应在内的所有 MCP 操作。这使其成为基于网络部署的推荐选择。

要使用 HTTP 传输，请在 `run()` 方法中指定它以及网络选项：

```python
from fastmcp import FastMCP

mcp = FastMCP("MyServer")

@mcp.tool
def hello(name: str) -> str:
    return f"Hello, {name}!"

if __name__ == "__main__":
    # 在 8000 端口启动一个 HTTP 服务器
    mcp.run(transport="http", host="127.0.0.1", port=8000)
```

您的服务器现在可以通过 `http://localhost:8000/mcp/` 访问。这个 URL 是客户端将连接的 MCP 端点。HTTP 传输启用了：
- 网络可访问性
- 多个并发客户端
- 与 Web 基础设施的集成
- 远程部署功能

有关具有身份验证和高级配置的生产 HTTP 部署，请参阅[自托管部署](/zh/deployment/self-hosted)指南。

### SSE 传输（遗留）

服务器发送事件（SSE）传输是 MCP 的原始基于 HTTP 的传输。虽然为了向后兼容性仍然支持，但与较新的流式 HTTP 传输相比，它有一些限制。SSE 只支持服务器到客户端的流式传输，使其在双向通信方面效率较低。

```python
if __name__ == "__main__":
    # SSE传输 - 对于新项目，请改用 HTTP 协议
    mcp.run(transport="sse", host="127.0.0.1", port=8000)
```

我们建议所有新项目使用 HTTP 传输而不是 SSE。SSE 仅保持可用以与尚未升级到流式 HTTP 的旧客户端兼容。

### 选择正确的传输协议

每种传输协议都服务于不同的需求。STDIO 在您需要简单的本地执行时是完美的 - 这是 Claude Desktop 和大多数命令行工具所期望的。HTTP 传输在您需要网络访问、希望服务多个客户端或计划远程部署服务器时是必需的。SSE 仅存在于向后兼容性，不应在新项目中使用。

考虑您的部署场景：您是在构建本地使用的工具吗？STDIO 是您的最佳选择。需要多个客户端可以访问的集中式服务？HTTP 传输是正确的选择。

## FastMCP CLI

FastMCP 提供了一个强大的命令行界面，用于在不修改源代码的情况下运行服务器。CLI 可以自动找到并运行您的服务器使用不同的传输协议、管理依赖项并处理开发工作流程：

```bash
fastmcp run server.py
```

CLI 会自动在您的文件中找到 FastMCP 实例（名为 `mcp`、`server` 或 `app`）并使用指定选项运行它。这对于测试不同的传输协议或配置而不更改代码特别有用。

### 依赖管理

CLI 与 `uv` 集成以管理 Python 环境和依赖项：

```bash
# 使用特定 Python 版本运行
fastmcp run server.py --python 3.11

# 使用附加包运行
fastmcp run server.py --with pandas --with numpy

# 使用需求文件中的依赖项运行
fastmcp run server.py --with-requirements requirements.txt

# 组合多个选项
fastmcp run server.py --python 3.10 --with httpx --transport http

# 在特定项目目录中运行
fastmcp run server.py --project /path/to/project
```

<Note>
当使用 `--python`、`--with`、`--project` 或 `--with-requirements` 时，服务器通过 `uv run` 子进程运行，而不是使用您的本地环境。
</Note>

### 向服务器传递参数

当服务器接受命令行参数（使用 argparse、click 或其他库）时，您可以在 `--` 后传递它们：

```bash
fastmcp run config_server.py -- --config config.json
fastmcp run database_server.py -- --database-path /tmp/db.sqlite --debug
```

这对于需要配置文件、数据库路径、API 密钥或其他运行时选项的服务器很有用。

有关更多 CLI 功能，包括使用 MCP Inspector 的开发模式，请参阅 [CLI 文档](/zh/patterns/cli)。

### 异步用法

FastMCP 服务器基于异步 Python 构建，但该框架提供同步和异步 API 来适应您应用程序的需求。我们一直使用的 `run()` 方法实际上是异步服务器实现的同步包装器。

对于已经在异步上下文中运行的应用程序，FastMCP 提供了 `run_async()` 方法：

```python {10-12}
from fastmcp import FastMCP
import asyncio

mcp = FastMCP(name="MyServer")

@mcp.tool
def hello(name: str) -> str:
    return f"Hello, {name}!"

async def main():
    # 在异步上下文中使用 run_async()
    await mcp.run_async(transport="http", port=8000)

if __name__ == "__main__":
    asyncio.run(main())
```

<Warning>
`run()` 方法不能在异步函数内调用，因为它在内部创建自己的异步事件循环。如果您尝试在异步函数内调用 `run()`，您将得到关于事件循环已经运行的错误。

始终在异步函数内使用 `run_async()`，在同步上下文中使用 `run()`。
</Warning>

`run()` 和 `run_async()` 都接受相同的传输参数，因此上面的所有示例都适用于这两种方法。

## 自定义路由

在使用 HTTP 传输时，您可能希望在 MCP 服务器旁边添加自定义 Web 端点。这对于健康检查、状态页面或简单 API 很有用。FastMCP 允许您使用 `@custom_route` 装饰器添加自定义路由：

```python
from fastmcp import FastMCP
from starlette.requests import Request
from starlette.responses import PlainTextResponse

mcp = FastMCP("MyServer")

@mcp.custom_route("/health", methods=["GET"])
async def health_check(request: Request) -> PlainTextResponse:
    return PlainTextResponse("OK")

@mcp.tool
def process(data: str) -> str:
    return f"已处理: {data}"

if __name__ == "__main__":
    mcp.run(transport="http")  # 健康检查 http://localhost:8000/health
```

自定义路由由与 MCP 端点相同的 Web 服务器提供服务。它们在您域名的根目录下可用，而 MCP 端点位于 `/mcp/`。对于更复杂的 Web 应用程序，请考虑[将您的 MCP 服务器挂载到 FastAPI 或 Starlette 应用中](/zh/deployment/self-hosted#integration-with-web-frameworks)。

## 替代初始化模式

`if __name__ == "__main__"` 模式适用于独立脚本，但某些部署场景需要不同的方法。FastMCP 会自动处理这些情况。

### 仅 CLI 服务器

在使用 FastMCP CLI 时，您根本不需要 `if __name__` 块。CLI 将找到您的 FastMCP 实例并运行它：

```python
# server.py
from fastmcp import FastMCP

mcp = FastMCP("MyServer")  # CLI 将查找'mcp'、'server'或'app'这些内容。

@mcp.tool
def process(data: str) -> str:
    return f"Processed: {data}"

# 不需要 if __name__ 块 - CLI 将找到并运行 'mcp'
```

### ASGI 应用程序

对于 ASGI 部署（使用 Uvicorn 或类似工具运行），您需要创建一个 ASGI 应用程序对象。这种方法在需要对服务器配置进行更多控制的生产部署中很常见：

```python
# app.py
from fastmcp import FastMCP

def create_app():
    mcp = FastMCP("MyServer")
    
    @mcp.tool
    def process(data: str) -> str:
        return f"已处理: {data}"
    
    return mcp.http_app()

app = create_app()  # Uvicorn 将使用这个
```

有关更多 ASGI 部署模式，请参阅[自托管部署](/zh/deployment/self-hosted)指南。