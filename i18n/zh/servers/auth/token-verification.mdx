---
title: 令牌验证
sidebarTitle: 令牌验证
description: 通过验证外部系统发行的承载令牌来保护您的服务器。
icon: key
tag: NEW
---

import { VersionBadge } from "/snippets/version-badge.mdx"

<VersionBadge version="2.11.0" />

令牌验证使您的 FastMCP 服务器能够验证外部系统发行的承载令牌，而无需参与用户身份验证流程。您的服务器充当纯资源服务器，专注于令牌验证和授权决策，同时将身份管理委托给基础设施中的其他系统。

<Note>
令牌验证在某种程度上在正式的 MCP 身份验证流程之外运行，该流程期望 OAuth 风格的发现。它最适合内部系统、微服务架构，或当您完全控制令牌生成和分发时。
</Note>

## 理解令牌验证

令牌验证解决身份验证责任分布在多个系统中的场景。您的 MCP 服务器接收包含身份和授权信息的结构化令牌，验证其真实性，并根据其内容做出访问控制决策。

这种模式在微服务架构中自然出现，其中中央身份验证服务发行令牌，多个下游服务独立验证。当将 MCP 服务器集成到已经建立了基于令牌的身份验证机制的现有系统中时，它也运行良好。

### 令牌验证模型

在 OAuth 术语中，令牌验证将您的 MCP 服务器视为资源服务器。关键洞察是令牌验证和令牌发行是可以由不同系统处理的独立关注点。

**令牌发行**：另一个系统（API 网关、身份验证服务或身份提供商）处理用户身份验证并创建包含身份和权限信息的签名令牌。

**令牌验证**：您的 MCP 服务器接收这些令牌，使用密码学签名验证其真实性，并从其声明中提取授权信息。

**访问控制**：基于令牌内容，您的服务器确定客户端可以访问哪些资源、工具和提示。

这种分离使您的 MCP 服务器能够专注于其核心功能，同时利用现有的身份验证基础设施。令牌充当随每个请求传递的可移植身份证明。

### 令牌安全考虑因素

基于令牌的身份验证依赖密码学签名来确保令牌完整性。您的 MCP 服务器使用与令牌创建所使用的私钥对应的公钥验证令牌。这种非对称方法意味着您的服务器永远不需要访问签名密钥。

令牌验证必须解决几个安全要求：签名验证确保令牌未被篡改，过期检查防止使用过时令牌，受众验证确保专为您的服务器设计的令牌不会被其他系统接受。

MCP 环境中的挑战是客户端需要在发出请求之前获得有效令牌，但 MCP 协议不为令牌端点提供内置发现机制。客户端必须通过单独的渠道或先前配置获取令牌。

## FastMCP 令牌验证

FastMCP 提供 `TokenVerifier` 类来处理令牌验证复杂性，同时在令牌源和验证策略方面保持灵活性。

### TokenVerifier 设计

`TokenVerifier` 专门专注于令牌验证，而不提供 OAuth 发现元数据。这使其非常适合客户端已经知道如何获取令牌的内部系统，或信任来自已知发行商的令牌的微服务。

该类验证令牌签名，检查过期时间戳，并从令牌声明中提取授权信息。它支持各种令牌格式和验证策略，同时为授权决策维护一致的接口。

您可以子类化 `TokenVerifier` 为专门的令牌格式或验证要求实现自定义验证逻辑。基类处理常见模式，同时允许对独特用例进行扩展。

### JWT 令牌验证

JSON Web Tokens (JWT) 代表现代应用程序最常见的令牌格式。FastMCP 的 `JWTVerifier` 使用行业标准的密码学技术和声明验证来验证 JWT。

#### JWKS 端点集成

JWKS 端点集成为生产系统提供了最灵活的方法。验证器自动从 JSON Web Key Set 端点获取公钥，实现自动密钥轮换而无需服务器配置更改。

```python
from fastmcp import FastMCP
from fastmcp.server.auth.providers.jwt import JWTVerifier

# 针对您的身份提供商配置 JWT 验证
verifier = JWTVerifier(
    jwks_uri="https://auth.yourcompany.com/.well-known/jwks.json",
    issuer="https://auth.yourcompany.com",
    audience="mcp-production-api"
)

mcp = FastMCP(name="受保护的 API", auth=verifier)
```

此配置创建一个验证由 `auth.yourcompany.com` 发行的 JWT 的服务器。验证器定期从 JWKS 端点获取公钥，并针对这些密钥验证传入令牌。只有具有正确发行商和受众声明的令牌才会被接受。

`issuer` 参数确保令牌来自您信任的身份验证系统，而 `audience` 验证防止专为其他服务设计的令牌被您的 MCP 服务器接受。

#### 对称密钥验证 (HMAC)

对称密钥验证使用共享密钥进行签名和验证，非常适合内部微服务和可信环境，在这些环境中可以安全地将同一密钥分发给令牌发行者和验证者。

这种方法常用于微服务架构中，其中服务共享密钥，或者当您的身份验证服务和 MCP 服务器都由同一组织管理时。当共享密钥得到正确管理时，HMAC 算法（HS256、HS384、HS512）提供强大的安全性。

```python
from fastmcp import FastMCP
from fastmcp.server.auth.providers.jwt import JWTVerifier

# 使用共享密钥进行对称密钥验证
verifier = JWTVerifier(
    public_key="your-shared-secret-key-minimum-32-chars",  # 尽管名称如此，但它接受对称密钥
    issuer="internal-auth-service",
    audience="mcp-internal-api",
    algorithm="HS256"  # 或 HS384、HS512 以获得更强的安全性
)

mcp = FastMCP(name="Internal API", auth=verifier)
```

验证器将使用指定的 HMAC 算法验证使用相同密钥签名的令牌。这种方法为内部系统提供了几个优势：

- **简单性**：无需密钥对管理或证书分发
- **性能**：HMAC 操作通常比 RSA 更快
- **兼容性**：与现有的微服务身份验证模式配合良好

<Note>
为了向后兼容，参数名为 `public_key`，但在使用 HMAC 算法（HS256/384/512）时，它接受对称密钥字符串。
</Note>

<Warning>
**对称密钥的安全注意事项：**
- 使用强随机生成的密钥（建议最少 32 个字符）
- 绝不在日志、错误消息或版本控制中暴露密钥
- 实现安全的密钥分发和轮换机制
- 对于面向外部的 API，考虑使用非对称密钥（RSA/ECDSA）
</Warning>

#### 静态公钥验证

静态公钥验证在您有固定的 RSA 或 ECDSA 签名密钥且不需要自动密钥轮换时有效。这种方法主要适用于开发环境或不可用 JWKS 端点的受控部署。

```python
from fastmcp import FastMCP
from fastmcp.server.auth.providers.jwt import JWTVerifier

# 使用静态公钥进行令牌验证
public_key_pem = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"""

verifier = JWTVerifier(
    public_key=public_key_pem,
    issuer="https://auth.yourcompany.com",
    audience="mcp-production-api"
)

mcp = FastMCP(name="受保护的 API", auth=verifier)
```

此配置使用特定的 RSA 或 ECDSA 公钥验证令牌。该密钥必须与您的令牌发行者使用的私钥相对应。尽管没有 JWKS 端点灵活，但这种方法在开发环境中或使用固定密钥进行测试时可能很有用。

### 开发和测试

开发环境通常需要更简单的令牌管理，而无需完整 JWT 基础设施的复杂性。FastMCP 提供专门为这些场景设计的工具。

#### 静态令牌验证

静态令牌验证通过接受具有相关声明的预定义令牌来实现快速开发。这种方法在开发和测试期间消除了对令牌生成基础设施的需要。

```python
from fastmcp import FastMCP
from fastmcp.server.auth.providers.jwt import StaticTokenVerifier

# 定义开发令牌及其相关声明
verifier = StaticTokenVerifier(
    tokens={
        "dev-alice-token": {
            "client_id": "alice@company.com",
            "scopes": ["read:data", "write:data", "admin:users"]
        },
        "dev-guest-token": {
            "client_id": "guest-user",
            "scopes": ["read:data"]
        }
    },
    required_scopes=["read:data"]
)

mcp = FastMCP(name="开发服务器", auth=verifier)
```

客户端现在可以使用 `Authorization: Bearer dev-alice-token` 标头进行身份验证。服务器将识别令牌并加载相关声明用于授权决策。这种方法实现了无外部依赖的即时开发。

<Warning>
静态令牌验证将令牌存储为纯文本，绝不应在生产环境中使用。它专门为开发和测试场景设计。
</Warning>

#### 测试令牌生成

当您需要测试 JWT 验证而无需设置完整的身份基础设施时，测试令牌生成很有帮助。FastMCP 包括用于生成测试密钥对和签名令牌的实用工具。

```python
from fastmcp.server.auth.providers.jwt import JWTVerifier, RSAKeyPair

# 生成测试用的密钥对
key_pair = RSAKeyPair.generate()

# 使用公钥配置您的服务器
verifier = JWTVerifier(
    public_key=key_pair.public_key,
    issuer="https://test.yourcompany.com",
    audience="test-mcp-server"
)

# 使用私钥生成测试令牌
test_token = key_pair.create_token(
    subject="test-user-123",
    issuer="https://test.yourcompany.com", 
    audience="test-mcp-server",
    scopes=["read", "write", "admin"]
)

print(f"测试令牌：{test_token}")
```

这种模式实现了对 JWT 验证逻辑的全面测试，而无需依赖外部令牌发行商。生成的令牌在密码学上有效，将通过所有标准 JWT 验证检查。

## 环境配置

<VersionBadge version="2.12.1" />

FastMCP 支持令牌验证的编程式和基于环境的配置，实现跨不同环境的灵活部署。

基于环境的配置将身份验证设置与应用程序代码分离，遵循十二因子应用原则并简化部署流水线。

```bash
# 启用 JWT 验证
export FASTMCP_SERVER_AUTH=fastmcp.server.auth.providers.jwt.JWTVerifier

# 使用 JWKS 端点进行非对称验证：
export FASTMCP_SERVER_AUTH_JWT_JWKS_URI="https://auth.company.com/.well-known/jwks.json"
export FASTMCP_SERVER_AUTH_JWT_ISSUER="https://auth.company.com"
export FASTMCP_SERVER_AUTH_JWT_AUDIENCE="mcp-production-api"
export FASTMCP_SERVER_AUTH_JWT_REQUIRED_SCOPES="read:data,write:data"

# 或者用于对称密钥验证 (HMAC)：
export FASTMCP_SERVER_AUTH_JWT_PUBLIC_KEY="your-shared-secret-key-minimum-32-chars"
export FASTMCP_SERVER_AUTH_JWT_ALGORITHM="HS256"  # 或 HS384、HS512
export FASTMCP_SERVER_AUTH_JWT_ISSUER="internal-auth-service"
export FASTMCP_SERVER_AUTH_JWT_AUDIENCE="mcp-internal-api"
```

配置了这些环境变量后，您的 FastMCP 服务器自动启用 JWT 验证：

```python
from fastmcp import FastMCP

# 身份验证自动从环境配置
mcp = FastMCP(name="生产 API")
```

这种方法使相同的代码库能够在具有不同身份验证要求的开发、预发布和生产环境中运行。开发环境可能使用静态令牌，而生产环境使用 JWT 验证，全部通过环境配置控制。

