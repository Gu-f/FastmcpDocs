---
title: 身份验证
sidebarTitle: 概述
description: 使用灵活的身份验证模式保护您的 FastMCP 服务器，从简单的 API 密钥到与外部身份提供商的完整 OAuth 2.1 集成。
icon: user-shield
tag: NEW
---

import { VersionBadge } from "/snippets/version-badge.mdx"

<VersionBadge version="2.11.0" />

MCP 中的身份验证提出了与传统 Web 应用程序不同的独特挑战。MCP 客户端需要自动发现身份验证要求，在无用户干预的情况下协商 OAuth 流，并在不同的身份提供商之间无缝工作。FastMCP 通过提供与 MCP 协议集成的身份验证模式来应对这些挑战，同时保持实现和部署的简单性。

<Tip>
身份验证仅适用于 FastMCP 的基于 HTTP 的传输（`http` 和 `sse`）。STDIO 传输从其本地执行环境继承安全性。
</Tip>

<Warning>
**MCP 中的身份验证正在快速发展。**规范和最佳实践正在快速变化。FastMCP 旨在提供稳定、安全的模式，这些模式能够适应这些变化，同时保持您的代码简单且易于维护。
</Warning>

## MCP 身份验证挑战

传统的 Web 身份验证假设有一个拥有浏览器的人类用户，可以与登录表单和同意屏幕交互。MCP 客户端通常是需要在无人干预的情况下进行身份验证的自动化系统。这创造了几个独特的要求：

**自动发现**：MCP 客户端必须通过检查服务器元数据来发现身份验证要求，而不是遇到登录重定向。

**编程式 OAuth**：OAuth 流必须在没有人类交互的情况下工作，依赖于预配置的凭据或动态客户端注册。

**令牌管理**：客户端需要在多个 MCP 服务器中自动获取、刷新和管理令牌。

**协议集成**：身份验证必须与 MCP 的传输机制和错误处理清晰地集成。

这些挑战意味着并不是所有的身份验证方法都适用于 MCP。可行的模式根据您的服务器承担的身份验证责任级别分为三类。

## 身份验证责任

身份验证责任存在于一个谱系上。您的 MCP 服务器可以验证在其他地方创建的令牌，与外部身份提供商协调，或在内部处理完整的身份验证生命周期。每种方法在简单性、安全性和控制力之间都涉及不同的权衡。

### 令牌验证

您的服务器验证令牌，但将其创建委托给外部系统。这种方法将您的 MCP 服务器视为纯资源服务器，信任由已知发行商签名的令牌。

令牌验证在您已经拥有可以发行结构化令牌（如 JWT）的身份验证基础设施时效果很好。您现有的 API 网关、微服务平台或企业 SSO 系统成为用户身份的信任源，而您的 MCP 服务器专注于其核心功能。

关键洞察是令牌验证将身份验证（证明您是谁）与授权（决定您可以做什么）分离开来。您的 MCP 服务器以签名令牌的形式接收身份证明，并根据该令牌内的声明做出访问决定。

这种模式在微服务架构中表现出色，其中多个服务需要验证相同的令牌，或者将 MCP 服务器集成到已经处理用户身份验证的现有系统中时。

### 外部身份提供商

您的服务器与已建立的身份提供商协调，为 MCP 客户端创建无缝的身份验证体验。这种方法利用 OAuth 2.0 和 OpenID Connect 协议来委托用户身份验证，同时保持对授权决定的控制。

外部身份提供商处理身份验证的复杂方面：用户凭据验证、多因素身份验证、账户恢复和安全监控。您的 MCP 服务器从这些可信提供商接收令牌，并使用提供商的公钥验证它们。

MCP 协议对动态客户端注册的支持使得这种模式特别强大。MCP 客户端可以自动发现您的身份验证要求，并在无需手动配置的情况下向您的身份提供商注册自己。

这种方法最适合需要企业级身份验证功能而不希望从头开始构建复杂性的生产应用程序。它在多个应用程序中扩展性良好，并提供一致的用户体验。

### 完整 OAuth 实现

您的服务器实现完整的 OAuth 2.0 授权服务器，处理从用户凭据验证到令牌生命周期管理的一切。这种方法以显著的复杂性为代价提供最大的控制力。

完整的 OAuth 实现意味着构建用于登录和同意的用户界面，实现安全的凭据存储，管理令牌生命周期，并维护持续的安全更新。复杂性超出了初始实现，还包括威胁监控、合规要求和跟上不断发展的安全最佳实践。

这种模式仅在您需要对身份验证过程完全控制、在空隙环境中运行或有外部提供商无法满足的专门要求时才有意义。

## FastMCP 身份验证提供者

FastMCP 将这些认证责任级别转换为多种具体类，用于处理 MCP 协议集成的复杂性。你可以基于这些类来处理 MCP 协议集成的复杂操作。

### 令牌验证器(TokenVerifier)

`TokenVerifier` 提供纯令牌验证，不包含 OAuth 元数据端点。此类专注于确定令牌是否有效并从其声明中提取授权信息的基本任务。

实现处理 JWT 签名验证、过期检查和声明提取。它针对已知发行商和受众验证令牌，确保为您的服务器而设的令牌不会被其他系统接受。

```python
from fastmcp import FastMCP
from fastmcp.server.auth.providers.jwt import JWTVerifier

auth = JWTVerifier(
    jwks_uri="https://your-auth-system.com/.well-known/jwks.json",
    issuer="https://your-auth-system.com", 
    audience="your-mcp-server"
)

mcp = FastMCP(name="受保护的服务器", auth=auth)
```

此示例配置针对 JWT 发行商的令牌验证。`JWTVerifier` 将从 JWKS 端点获取公钥，并针对这些钥验证传入的令牌。只有具有正确发行商和受众声明的令牌才会被接受。

`TokenVerifier` 在您控制令牌发行商和 MCP 服务器或与现有基于 JWT 的基础设施集成时效果很好。

→ **完整指南**：[令牌验证](/zh/servers/auth/token-verification)

### 远程身份验证提供者(RemoteAuthProvider)

`RemoteAuthProvider` 允许与 **支持动态客户端注册（DCR）** 的身份提供者进行认证，例如 WorkOS AuthKit。通过 DCR，MCP 客户端可以自动向身份提供者注册自身并获取凭证，无需任何手动配置。

此类将令牌验证与 OAuth 发现元数据结合起来。它通过添加 OAuth 2.0 受保护的资源端点来扩展 `TokenVerifier` 的功能，这些端点会声明你的认证要求。MCP 客户端会检查这些端点，以了解你信任哪些身份提供者以及如何获取有效令牌。

关键要求是你的身份提供者必须支持 DCR——即客户端能够动态注册并获取凭证的能力。这正是实现 MCP 所需的无缝自动化认证流程的前提。

例如，内置的 `AuthKitProvider` 使用 WorkOS AuthKit，它完全支持 DCR：

```python
from fastmcp import FastMCP
from fastmcp.server.auth.providers.workos import AuthKitProvider

auth = AuthKitProvider(
    authkit_domain="https://your-project.authkit.app",
    base_url="https://your-fastmcp-server.com"
)

mcp = FastMCP(name="企业服务器", auth=auth)
```

此示例使用 WorkOS AuthKit 作为外部身份提供商。`AuthKitProvider` 自动配置针对 WorkOS 的令牌验证，并提供 MCP 客户端自动身份验证所需的 OAuth 元数据。

当你的身份提供者支持动态客户端注册（DCR）时，`RemoteAuthProvider` 非常适合用于生产环境应用。这可以实现完全自动化的认证，无需手动配置客户端。

→ **完整指南**：[远程 OAuth](/zh/servers/auth/remote-oauth)

### OAuth代理(OAuthProxy)

<VersionBadge version="2.12.0" />

`OAuthProxy` 支持与**不支持动态客户端注册（DCR）**的 OAuth 提供商进行身份验证，例如 GitHub、Google、Azure 和大多数传统企业身份系统。

当身份提供商需要手动应用注册和固定凭据时，`OAuthProxy` 充当桥梁。它向 MCP 客户端提供符合 DCR 的接口（接受任何注册请求），同时使用您在上游提供商处预注册的凭据。代理处理回调转发的复杂性，使动态客户端回调能够与需要固定重定向 URI 的提供商配合使用。

此类解决了 MCP 对动态注册期望与传统 OAuth 提供商手动应用注册要求之间的根本不兼容性。

例如，内置的 `GitHubProvider` 扩展 `OAuthProxy` 以与 GitHub 的 OAuth 系统配合使用：

```python
from fastmcp import FastMCP
from fastmcp.server.auth.providers.github import GitHubProvider

auth = GitHubProvider(
    client_id="Ov23li...",  # 您的 GitHub OAuth 应用 ID
    client_secret="abc123...",  # 您的 GitHub OAuth 应用密钥
    base_url="https://your-server.com"
)

mcp = FastMCP(name="GitHub 保护的服务器", auth=auth)
```

此示例使用 GitHub 提供商，它使用 GitHub 特定的令牌验证扩展了 `OAuthProxy`。代理处理完整的 OAuth 流程，同时使 GitHub 的非 DCR 身份验证与 MCP 客户端无缝配合。

当与不支持 DCR 的 OAuth 提供商集成时，`OAuthProxy` 是必不可少的。这包括大多数已建立的提供商，如 GitHub、Google 和 Azure，它们需要通过其开发者控制台进行手动应用注册。

→ **完整指南**：[OAuth 代理](/zh/servers/auth/oauth-proxy)

### OAuth提供者(OAuthProvider)

`OAuthProvider` 在您的 MCP 服务器内实现完整的 OAuth 2.0 授权服务器。此类处理从用户凭据验证到令牌管理的完整身份验证生命周期。

实现提供所有所需的 OAuth 端点，包括授权、令牌和发现端点。它管理客户端注册、用户同意和令牌生命周期，同时与您的用户存储和身份验证逻辑集成。

```python
from fastmcp import FastMCP
from fastmcp.server.auth.providers.oauth import MyOAuthProvider

auth = MyOAuthProvider(
    user_store=your_user_database,
    client_store=your_client_registry,
    # 额外配置...
)

mcp = FastMCP(name="身份验证服务器", auth=auth)
```

此示例显示了自定义 OAuth 提供商的基本结构。实际实现需要在用户管理、客户端注册和安全策略方面进行大量额外配置。

`OAuthProvider` 仅应在您有外部提供商无法满足的特定要求并且具备安全实现 OAuth 的专业知识时使用。

→ **完整指南**：[完整 OAuth 服务器](/zh/servers/auth/full-oauth-server)

## 配置方法

FastMCP 支持编程式配置（以获得最大灵活性）和基于环境的配置（以简化部署）。

### 编程式配置

编程式配置提供对身份验证设置的完全控制，并允许复杂的初始化逻辑。这种方法在开发期间和需要根据运行时条件自定义身份验证行为时效果很好。

身份验证提供商在您的代码中直接使用其所需参数进行实例化。这使依赖关系明确，并允许您的 IDE 提供有用的自动完成和类型检查。

### 环境配置

<VersionBadge version="2.12.1" />

Environment-based configuration separates authentication settings from application code, enabling the same codebase to work across different deployment environments without modification.

FastMCP automatically detects authentication configuration from environment variables when no explicit `auth` parameter is provided. The configuration system supports all authentication providers and their various options.

#### Provider Configuration

Authentication providers are configured by specifying the full module path to the provider class:

<ParamField path="FASTMCP_SERVER_AUTH" type="string">
The full module path to the authentication provider class. Examples:
- `fastmcp.server.auth.providers.github.GitHubProvider` - GitHub OAuth
- `fastmcp.server.auth.providers.google.GoogleProvider` - Google OAuth
- `fastmcp.server.auth.providers.jwt.JWTVerifier` - JWT token verification
- `fastmcp.server.auth.providers.workos.WorkOSProvider` - WorkOS OAuth
- `fastmcp.server.auth.providers.workos.AuthKitProvider` - WorkOS AuthKit
- `mycompany.auth.CustomProvider` - Your custom provider class
</ParamField>

When using providers like GitHub or Google, you'll need to set provider-specific environment variables:

```bash
# GitHub OAuth
export FASTMCP_SERVER_AUTH=fastmcp.server.auth.providers.github.GitHubProvider
export FASTMCP_SERVER_AUTH_GITHUB_CLIENT_ID="Ov23li..."
export FASTMCP_SERVER_AUTH_GITHUB_CLIENT_SECRET="github_pat_..."

# Google OAuth
export FASTMCP_SERVER_AUTH=fastmcp.server.auth.providers.google.GoogleProvider
export FASTMCP_SERVER_AUTH_GOOGLE_CLIENT_ID="123456.apps.googleusercontent.com"
export FASTMCP_SERVER_AUTH_GOOGLE_CLIENT_SECRET="GOCSPX-..."
```

#### Provider-Specific Configuration

Each provider has its own configuration options set through environment variables:

```bash
# JWT Token Verification
export FASTMCP_SERVER_AUTH=fastmcp.server.auth.providers.jwt.JWTVerifier
export FASTMCP_SERVER_AUTH_JWT_JWKS_URI="https://auth.example.com/jwks"
export FASTMCP_SERVER_AUTH_JWT_ISSUER="https://auth.example.com"
export FASTMCP_SERVER_AUTH_JWT_AUDIENCE="mcp-server"

# Custom Provider
export FASTMCP_SERVER_AUTH=mycompany.auth.CustomProvider
# Plus any environment variables your custom provider expects
```

With these environment variables set, creating an authenticated FastMCP server requires no additional configuration:

```python
from fastmcp import FastMCP

# 身份验证自动从环境中配置
mcp = FastMCP(name="我的服务器")
```

这种方法简化了部署流水线，并遵循配置管理的十二因子应用原则。

## 选择您的实现

The authentication approach you choose depends on your existing infrastructure, security requirements, and operational constraints.

**For OAuth providers without DCR support (GitHub, Google, Azure, most enterprise systems), use OAuth Proxy.** These providers require manual app registration through their developer consoles. OAuth Proxy bridges the gap by presenting a DCR-compliant interface to MCP clients while using your fixed credentials with the provider. The proxy's callback forwarding pattern enables dynamic client ports to work with providers that require fixed redirect URIs.

**For identity providers with DCR support (WorkOS AuthKit, modern auth platforms), use RemoteAuthProvider.** These providers allow clients to dynamically register and obtain credentials without manual configuration. This enables the fully automated authentication flow that MCP is designed for, providing the best user experience and simplest implementation.

**Token validation works well when you already have authentication infrastructure that issues structured tokens.** If your organization already uses JWT-based systems, API gateways, or enterprise SSO that can generate tokens, this approach integrates seamlessly while keeping your MCP server focused on its core functionality. The simplicity comes from leveraging existing investment in authentication infrastructure.

**Full OAuth implementation should be avoided unless you have compelling reasons that external providers cannot address.** Air-gapped environments, specialized compliance requirements, or unique organizational constraints might justify this approach, but it requires significant security expertise and ongoing maintenance commitment. The complexity extends far beyond initial implementation to include threat monitoring, security updates, and keeping pace with evolving attack vectors.

FastMCP's architecture supports migration between these approaches as your requirements evolve. You can integrate with existing token systems initially and migrate to external identity providers as your application scales, or implement custom solutions when your requirements outgrow standard patterns.