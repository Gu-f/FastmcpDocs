---
title: 工具
sidebarTitle: 工具
description: 将函数作为可执行功能暴露给您的 MCP 客户端。
icon: wrench
---

import { VersionBadge } from '/snippets/version-badge.mdx'

工具是核心构建块，允许您的 LLM 与外部系统交互、执行代码并访问不在其训练数据中的数据。在 FastMCP 中，工具是通过 MCP 协议暴露给 LLM 的 Python 函数。

## 什么是工具？

FastMCP 中的工具将常规 Python 函数转换为 LLM 在对话期间可以调用的功能。当 LLM 决定使用工具时：

1.  它发送一个基于工具架构的带参数的请求。
2.  FastMCP 根据您函数的签名验证这些参数。
3.  您的函数使用验证的输入执行。
4.  结果返回给 LLM，LLM 可以在其响应中使用它。

这允许 LLM 执行查询数据库、调用 API、进行计算或访问文件等任务——将其功能扩展到训练数据之外。

## 工具

### `@tool` 装饰器

创建工具就像用 `@mcp.tool` 装饰 Python 函数一样简单：

```python
from fastmcp import FastMCP

mcp = FastMCP(name="CalculatorServer")

@mcp.tool
def add(a: int, b: int) -> int:
    """将两个整数相加。"""
    return a + b
```

当此工具注册时，FastMCP 自动：
- 使用函数名称（`add`）作为工具名称。
- 使用函数的文档字符串（`将两个整数相加...`）作为工具描述。
- 基于函数的参数和类型注解生成输入架构。
- 处理参数验证和错误报告。

您定义 Python 函数的方式决定了工具如何为 LLM 客户端进行展示和执行行为。

<Tip>
不支持带有 `*args` 或 `**kwargs` 的函数作为工具。存在此限制是因为 FastMCP 需要为 MCP 协议生成完整的参数架构，这对于可变参数列表是不可能的。
</Tip>

#### 装饰器参数

虽然 FastMCP 从您的函数中推断名称和描述，但您可以使用 `@mcp.tool` 装饰器的参数来覆盖这些并添加额外的元数据：

```python
@mcp.tool(
    name="find_products",           # LLM 的自定义工具名称
    description="搜索产品目录，可选择类别过滤。", # 自定义描述
    tags={"catalog", "search"},      # 用于组织/过滤的可选标签
    meta={"version": "1.2", "author": "product-team"}  # 自定义元数据
)
def search_products_implementation(query: str, category: str | None = None) -> list[dict]:
    """内部函数描述（如果上面提供了描述则忽略）。"""
    # 实现...
    print(f"Searching for '{query}' in category '{category}'")
    return [{"id": 2, "name": "Another Product"}]
```

<Card icon="code" title="@tool 装饰器参数">
<ParamField body="name" type="str | None">
  设置通过 MCP 暴露的显式工具名称。如果未提供，则使用函数名称
</ParamField>

<ParamField body="description" type="str | None">
  提供通过 MCP 暴露的描述。如果设置，函数的文档字符串将被忽略
</ParamField>

<ParamField body="tags" type="set[str] | None">
  用于对工具进行分类的字符串集合。服务器和在某些情况下客户端可以使用这些来过滤或分组可用工具。
</ParamField>

<ParamField body="enabled" type="bool" default="True">
  启用或禁用工具的布尔值。更多信息请参阅[禁用工具](#disabling-tools)
</ParamField>

<ParamField body="exclude_args" type="list[str] | None">
  要从显示给 LLM 的工具架构中排除的参数名称列表。更多信息请参阅[排除参数](#excluding-arguments)
</ParamField>

<ParamField body="annotations" type="ToolAnnotations | dict | None">
    可选的 `ToolAnnotations` 对象或字典，用于添加关于工具的额外元数据。
  <Expandable title="ToolAnnotations 属性">
    <ParamField body="title" type="str | None">
      工具的人类可读标题。
    </ParamField>
    <ParamField body="readOnlyHint" type="bool | None">
      如果为 true，工具不会修改其环境。
    </ParamField>
    <ParamField body="destructiveHint" type="bool | None">
      如果为 true，工具可能对其环境执行破坏性更新。
    </ParamField>
    <ParamField body="idempotentHint" type="bool | None">
      如果为 true，使用相同参数重复调用工具对其环境不会产生额外影响。
    </ParamField>
    <ParamField body="openWorldHint" type="bool | None">
      如果为 true，此工具可能与外部实体的"开放世界"交互。如果为 false，工具的交互域是封闭的。
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="meta" type="dict[str, Any] | None">
  <VersionBadge version="2.11.0" />
  
  关于工具的可选元信息。此数据作为客户端工具对象的 `_meta` 字段传递给 MCP 客户端，可用于自定义元数据、版本控制或其他应用程序特定目的。
</ParamField>
</Card>


### 异步和同步工具

FastMCP 是一个异步优先的框架，无缝支持异步（`async def`）和同步（`def`）函数作为工具。对于 I/O 绑定操作，首选异步工具以保持服务器响应。

虽然同步工具在 FastMCP 中无缝工作，但它们在执行期间可能会阻塞事件循环。对于 CPU 密集型或可能阻塞的同步操作，请考虑替代策略。一种方法是使用 `anyio`（FastMCP 内部已经使用）将它们包装为异步函数，例如：

```python {1, 13}
import anyio
from fastmcp import FastMCP

mcp = FastMCP()

def cpu_intensive_task(data: str) -> str:
    # 一些可能阻塞事件循环的重型计算
    return processed_data

@mcp.tool
async def wrapped_cpu_task(data: str) -> str:
    """包装的 CPU 密集型任务以防止阻塞。"""
    return await anyio.to_thread.run_sync(cpu_intensive_task, data)
```

替代方法包括使用 `asyncio.get_event_loop().run_in_executor()` 或其他线程技术来管理阻塞操作，而不影响服务器响应性。例如，这里有一个使用 `asyncer` 库（不包含在 FastMCP 中）创建包装同步函数的装饰器的方法，感谢 [@hsheth2](https://github.com/jlowin/fastmcp/issues/864#issuecomment-3103678258)：

<CodeGroup>
```python 装饰器方法
import asyncer
import functools
from typing import Callable, ParamSpec, TypeVar, Awaitable

_P = ParamSpec("_P")
_R = TypeVar("_R")

def make_async_background(fn: Callable[_P, _R]) -> Callable[_P, Awaitable[_R]]:
    @functools.wraps(fn)
    async def wrapper(*args: _P.args, **kwargs: _P.kwargs) -> _R:
        return await asyncer.asyncify(fn)(*args, **kwargs)

    return wrapper
```

```python 使用装饰器 {6}
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool()
@make_async_background
def my_tool() -> None:
    time.sleep(5)
```
</CodeGroup>


### 类型注解

参数的类型注解对于正确的工具功能至关重要。它们：
1. 向 LLM 通知每个参数的预期数据类型
2. 使 FastMCP 能够验证来自客户端的输入数据
3. 为 MCP 协议生成准确的 JSON 架构

对参数使用标准 Python 类型注解：

```python
@mcp.tool
def analyze_text(
    text: str,
    max_tokens: int = 100,
    language: str | None = None
) -> dict:
    """分析提供的文本。"""
    # 实现...
```

FastMCP 支持广泛的类型注解，包括所有 Pydantic 类型：

| 类型注解                 | 示例                          | 描述                               |
| :---------------------- | :---------------------------- | :---------------------------------- |
| 基本类型                | `int`, `float`, `str`, `bool` | 简单标量值 - 请参阅[内置类型](#built-in-types) |
| 二进制数据              | `bytes`                       | 二进制内容 - 请参阅[二进制数据](#binary-data) |
| 日期和时间              | `datetime`, `date`, `timedelta` | 日期和时间对象 - 请参阅[日期和时间类型](#date-and-time-types) |
| 集合类型                | `list[str]`, `dict[str, int]`, `set[int]` | 项目集合 - 请参阅[集合类型](#collection-types) |
| 可选类型                | `float \| None`, `Optional[float]`| 可能为空/省略的参数 - 请参阅[联合和可选类型](#union-and-optional-types) |
| 联合类型                | `str \| int`, `Union[str, int]`| 接受多种类型的参数 - 请参阅[联合和可选类型](#union-and-optional-types) |
| 受限类型                | `Literal["A", "B"]`, `Enum`   | 具有特定允许值的参数 - 请参阅[受限类型](#constrained-types) |
| 路径                    | `Path`                        | 文件系统路径 - 请参阅[路径](#paths) |
| UUID                    | `UUID`                        | 通用唯一标识符 - 请参阅[UUID](#uuids) |
| Pydantic 模型           | `UserData`                    | 复杂结构化数据 - 请参阅[Pydantic 模型](#pydantic-models) |

有关此处未列出的其他类型注解，请参阅下面的[参数类型](#parameter-types)部分，获取更详细的信息和示例。
### 参数元数据

您可以通过几种方式提供关于参数的额外元数据：

#### 简单字符串描述

<VersionBadge version="2.11.0" />

对于基本参数描述，您可以使用 `Annotated` 的便捷简写：

```python 
from typing import Annotated

@mcp.tool
def process_image(
    image_url: Annotated[str, "要处理的图像的 URL"],
    resize: Annotated[bool, "是否调整图像大小"] = False,
    width: Annotated[int, "目标宽度（像素）"] = 800,
    format: Annotated[str, "输出图像格式"] = "jpeg"
) -> dict:
    """处理图像并可选择调整大小。"""
    # 实现...
```

此简写语法等同于使用 `Field(description=...)`，但对于简单描述更简洁。

<Tip>
此简写语法仅适用于带有单个字符串描述的 `Annotated` 类型。
</Tip>

#### 使用 Field 的高级元数据

对于验证约束和高级元数据，使用 Pydantic 的 `Field` 类与 `Annotated`：

```python
from typing import Annotated
from pydantic import Field

@mcp.tool
def process_image(
    image_url: Annotated[str, Field(description="要处理的图像的 URL")],
    resize: Annotated[bool, Field(description="是否调整图像大小")] = False,
    width: Annotated[int, Field(description="目标宽度（像素）", ge=1, le=2000)] = 800,
    format: Annotated[
        Literal["jpeg", "png", "webp"], 
        Field(description="输出图像格式")
    ] = "jpeg"
) -> dict:
    """处理图像并可选择调整大小。"""
    # 实现...
```


您也可以将 Field 用作默认值，尽管首选 Annotated 方法：

```python
@mcp.tool
def search_database(
    query: str = Field(description="搜索查询字符串"),
    limit: int = Field(10, description="最大结果数量", ge=1, le=100)
) -> list:
    """使用提供的查询搜索数据库。"""
    # 实现...
```

Field 提供几个验证和文档功能：
- `description`：参数的人类可读解释（显示给 LLM）
- `ge`/`gt`/`le`/`lt`：大于/小于（或等于）约束
- `min_length`/`max_length`：字符串或集合长度约束
- `pattern`：字符串验证的正则表达式模式
- `default`：如果省略参数的默认值



### 可选参数

FastMCP 遵循 Python 的标准函数参数约定。没有默认值的参数是必需的，而有默认值的参数是可选的。

```python
@mcp.tool
def search_products(
    query: str,                   # 必需 - 无默认值
    max_results: int = 10,        # 可选 - 有默认值
    sort_by: str = "relevance",   # 可选 - 有默认值
    category: str | None = None   # 可选 - 可以为 None
) -> list[dict]:
    """搜索产品目录。"""
    # 实现...
```

在此示例中，LLM 必须提供 `query` 参数，而 `max_results`、`sort_by` 和 `category` 如果未明确提供将使用其默认值。


### 排除参数

<VersionBadge version="2.6.0" /> 

您可以从显示给 LLM 的工具架构中排除某些参数。这对于在运行时注入的参数（如 `state`、`user_id` 或凭据）很有用，这些参数不应暴露给 LLM 或客户端。只有具有默认值的参数才能被排除；尝试排除必需参数将引发错误。

示例：

```python
@mcp.tool(
    name="get_user_details",
    exclude_args=["user_id"]
)
def get_user_details(user_id: str = None) -> str:
    # user_id 将由服务器注入，不是由 LLM 提供
    ...
```

使用此配置，`user_id` 不会出现在工具的参数架构中，但仍可以在运行时由服务器或框架设置。

有关更复杂的工具转换，请参阅[转换工具](/zh/patterns/tool-transformation)。

### 禁用工具

<VersionBadge version="2.8.0" />

您可以通过启用或禁用工具来控制工具的可见性和可用性。这对于功能标记、维护或动态更改客户端可用的工具集很有用。禁用的工具不会出现在 `list_tools` 返回的可用工具列表中，尝试调用禁用的工具将导致"未知工具"错误，就像工具不存在一样。

默认情况下，所有工具都是启用的。您可以在创建时使用装饰器中的 `enabled` 参数禁用工具：

```python
@mcp.tool(enabled=False)
def maintenance_tool():
    """此工具目前正在维护中。"""
    return "This tool is disabled."
```

您也可以在创建工具后以编程方式切换工具状态：

```python
@mcp.tool
def dynamic_tool():
    return "I am a dynamic tool."

# 禁用和重新启用工具
dynamic_tool.disable()
dynamic_tool.enable()
```

### 返回值


FastMCP 工具可以以两种互补格式返回数据：**传统内容块**（如文本和图像）和**结构化输出**（机器可读的 JSON）。当您添加返回类型注解时，FastMCP 自动生成**输出架构**来验证结构化数据，并使客户端能够将结果反序列化为 Python 对象。

了解这三个概念如何协同工作：

- **返回值**：您的 Python 函数返回的内容（决定内容块和结构化数据）
- **结构化输出**：与传统内容一起发送的 JSON 数据，用于机器处理
- **输出架构**：描述和验证结构化输出格式的 JSON Schema 声明

以下部分详细解释每个概念。

#### 内容块

FastMCP 自动将工具返回值转换为适当的 MCP 内容块：

- **`str`**: 作为 `TextContent` 发送
- **`bytes`**: Base64 编码并作为 `BlobResourceContents` 发送（在 `EmbeddedResource` 内）
- **`fastmcp.utilities.types.Image`**: 作为 `ImageContent` 发送
- **`fastmcp.utilities.types.Audio`**: 作为 `AudioContent` 发送
- **`fastmcp.utilities.types.File`**: 作为 base64 编码的 `EmbeddedResource` 发送
- **以上任何类型的列表**: 自动转换每个项
- **`None`**: 结果为空响应

#### 结构化输出

<VersionBadge version="2.10.0" />

2025年6月18日的 MCP 规范更新[引入了](https://modelcontextprotocol.io/specification/2025-06-18/server/tools#structured-content)结构化内容，这是一种从工具返回数据的新方式。结构化内容是与传统内容一起发送的 JSON 对象。当您的工具返回具有 JSON 对象表示的数据时，FastMCP 会自动在传统内容旁边创建结构化输出。这提供了客户端可以反序列化回 Python 对象的机器可读 JSON 数据。

**自动结构化内容规则：**
- **类对象结果**（`dict`、Pydantic 模型、dataclasses 数据类）→ 始终成为结构化内容（即使没有输出Schema）
- **非对象结果**（`int`、`str`、`list`）→ 只有在有输出架构来验证/序列化它们时才成为结构化内容
- **所有结果** → 为了向后兼容，始终成为传统内容块

<Note>
这种自动行为使客户端能够接收机器可读数据和人类可读内容，而无需为类对象返回明确的输出Schema。
</Note>

##### 类对象结果（自动结构化内容）

<CodeGroup>
```python 字典返回（无需Schema）
@mcp.tool
def get_user_data(user_id: str) -> dict:
    """获取用户数据，无类型注解。"""
    return {"name": "Alice", "age": 30, "active": True}
```

```json 传统内容
"{\n  \"name\": \"Alice\",\n  \"age\": 30,\n  \"active\": true\n}"
```

```json 结构化内容（自动）
{
  "name": "Alice", 
  "age": 30,
  "active": true
}
```
</CodeGroup>

##### 非对象结果（需要定义Schema）

<CodeGroup>
```python 整数返回（无需Schema）
@mcp.tool  
def calculate_sum(a: int, b: int):
    """计算总和，无返回注解。"""
    return a + b  # 返回 8
```

```json 仅传统内容
"8"
```

```python 整数返回（有Schema）
@mcp.tool
def calculate_sum(a: int, b: int) -> int:
    """计算总和，有返回注解。"""  
    return a + b  # 返回 8
```

```json 传统内容
"8"
```

```json 结构化内容（来自Schema）
{
  "result": 8
}
```
</CodeGroup>

##### 复杂类型示例

<CodeGroup>
```python 工具定义
from dataclasses import dataclass
from fastmcp import FastMCP

mcp = FastMCP()

@dataclass
class Person:
    name: str
    age: int
    email: str

@mcp.tool
def get_user_profile(user_id: str) -> Person:
    """获取用户的配置文件信息。"""
    return Person(name="Alice", age=30, email="alice@example.com")
```

```json 生成的输出结构
{
  "properties": {
    "name": {"title": "Name", "type": "string"},
    "age": {"title": "Age", "type": "integer"}, 
    "email": {"title": "Email", "type": "string"}
  },
  "required": ["name", "age", "email"],
  "title": "Person",
  "type": "object"
}
```

```json 结构化输出
{
  "name": "Alice",
  "age": 30,
  "email": "alice@example.com"
}
```
</CodeGroup>

#### 输出Schema

<VersionBadge version="2.10.0" />

2025年6月18日的 MCP 规范更新[引入了](https://modelcontextprotocol.io/specification/2025-06-18/server/tools#output-schema)输出架构，这是一种描述工具预期输出格式的新方式。当提供输出架构时，工具*必须*返回与架构匹配的结构化输出。

当您向函数添加返回类型注解时，FastMCP 会自动生成描述预期输出格式的 JSON 架构。这些架构帮助 MCP 客户端理解和验证它们接收到的结构化数据。

##### 原始类型包装

对于原始返回类型（如 `int`、`str`、`bool`），FastMCP 会自动将结果包装在 `"result"` 键下以创建有效的结构化输出：

<CodeGroup>
```python 原始返回类型
@mcp.tool
def calculate_sum(a: int, b: int) -> int:
    """将两个数字相加。"""
    return a + b
```

```json 生成的Schema（包装）
{
  "type": "object",
  "properties": {
    "result": {"type": "integer"}
  },
  "x-fastmcp-wrap-result": true
}
```

```json 结构化输出
{
  "result": 8
}
```
</CodeGroup>

##### 手动Schema控制

您可以通过提供自定义 `output_schema` 来覆盖自动生成的架构：

```python
@mcp.tool(output_schema={
    "type": "object", 
    "properties": {
        "data": {"type": "string"},
        "metadata": {"type": "object"}
    }
})
def custom_schema_tool() -> dict:
    """具有自定义输出架构的工具。"""
    return {"data": "Hello", "metadata": {"version": "1.0"}}
```

架构生成适用于大多数常见类型，包括基本类型、集合、联合类型、Pydantic 模型、TypedDict 结构和dataclasses 数据类。

<Warning>
**重要约束**：
- 输出架构必须是对象类型（`"type": "object"`）
- 如果您提供输出Schema，您的工具**必须**返回与其匹配的结构化输出
- 但是，您可以在没有输出Schema的情况下提供结构化输出（使用 `ToolResult`）
</Warning>

#### 使用 ToolResult 完全控制

要完全控制传统内容和结构化输出，请返回 `ToolResult` 对象：

```python
from fastmcp.tools.tool import ToolResult

@mcp.tool
def advanced_tool() -> ToolResult:
    """完全控制输出的工具。"""
    return ToolResult(
        content=[TextContent(text="人类可读摘要")],
        structured_content={"data": "value", "count": 42}
    )
```

当返回 `ToolResult` 时：
- 您可以准确控制发送什么内容和结构化数据
- 输出Schemas是可选的 - 结构化内容可以在没有Schema的情况下提供
- 客户端接收传统内容块和结构化数据

<Note>
如果您的返回类型注解不能转换为 JSON Schema（例如，没有 Pydantic 支持的复杂自定义类），输出Schema将被省略，但工具仍将正常工作，使用传统内容。
</Note>

### 错误处理

<VersionBadge version="2.4.1" />

如果您的工具遇到错误，您可以引发标准 Python 异常（`ValueError`、`TypeError`、`FileNotFoundError`、自定义异常等）或 FastMCP `ToolError`。

默认情况下，所有异常（包括它们的详细信息）都会被记录并转换为 MCP 错误响应发送回客户端 LLM。这有助于 LLM 理解失败并做出适当反应。

如果您出于安全原因想要掩盖内部错误详细信息，您可以：

1. 在创建 `FastMCP` 实例时使用 `mask_error_details=True` 参数：
```python
mcp = FastMCP(name="SecureServer", mask_error_details=True)
```

2. 或使用 `ToolError` 显式控制发送给客户端的错误信息：
```python
from fastmcp import FastMCP
from fastmcp.exceptions import ToolError

@mcp.tool
def divide(a: float, b: float) -> float:
    """将 a 除以 b。"""

    if b == 0:
        # 来自 ToolError 的错误消息始终发送给客户端，
        # 无论 mask_error_details 设置如何
        raise ToolError("不允许除以零。")
    
    # 如果 mask_error_details=True，此消息将被掩盖
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise TypeError("两个参数都必须是数字。")
        
    return a / b
```

当 `mask_error_details=True` 时，只有来自 `ToolError` 的错误消息会包含详细信息，其他异常将被转换为通用消息。

### 注解

<VersionBadge version="2.2.7" />

FastMCP 允许您通过注解向工具添加专用元数据。这些注解向客户端应用程序传达工具的行为方式，而不会在 LLM 提示中消耗令牌上下文。

注解在客户端应用程序中有几个用途：
- 为显示目的添加用户友好的标题
- 指示工具是否修改数据或系统
- 描述工具的安全配置文件（破坏性 vs. 非破坏性）
- 表明工具是否与外部系统交互

您可以在 `@mcp.tool` 装饰器中使用 `annotations` 参数向工具添加注解：

```python
@mcp.tool(
    annotations={
        "title": "计算总和",
        "readOnlyHint": True,
        "openWorldHint": False
    }
)
def calculate_sum(a: float, b: float) -> float:
    """将两个数字相加。"""
    return a + b
```

FastMCP 支持这些标准注解：

| 注解 | 类型 | 默认值 | 用途 |
| :--------- | :--- | :------ | :------ |
| `title` | string | - | 用户界面的显示名称 |
| `readOnlyHint` | boolean | false | 指示工具是否只读取而不做更改 |
| `destructiveHint` | boolean | true | 对于非只读工具，表示更改是否具有破坏性 |
| `idempotentHint` | boolean | false | 指示重复的相同调用是否与单个调用具有相同效果 |
| `openWorldHint` | boolean | true | 指定工具是否与外部系统交互 |

请记住，注解有助于提供更好的用户体验，但应被视为建议性提示。它们帮助客户端应用程序提供适当的 UI 元素和安全控制，但不会自己强制执行安全边界。始终专注于使您的注解准确地代表您的工具实际所做的事情。

### 通知

<VersionBadge version="2.9.1" />

当工具被添加、移除、启用或禁用时，FastMCP 会自动向连接的客户端发送 `notifications/tools/list_changed` 通知。这允许客户端保持最新的工具集，而无需手动轮询更改。

```python
@mcp.tool
def example_tool() -> str:
    return "Hello!"

# 这些操作会触发通知：
mcp.add_tool(example_tool)     # 发送 tools/list_changed 通知
example_tool.disable()         # 发送 tools/list_changed 通知  
example_tool.enable()          # 发送 tools/list_changed 通知
mcp.remove_tool("example_tool") # 发送 tools/list_changed 通知
```

只有当这些操作在活动的 MCP 请求上下文中发生时（例如，从工具内或其他 MCP 操作中调用时），才会发送通知。在服务器初始化期间执行的操作不会触发通知。

客户端可以使用[消息处理程序](/zh/clients/messages)处理这些通知，以自动刷新其工具列表或更新其界面。

## MCP 上下文

工具可以通过 `Context` 对象访问 MCP 功能，如记录日志、读取资源或报告进度。要使用它，请在工具函数中添加一个带有类型提示的 `Context` 参数。

```python
from fastmcp import FastMCP, Context

mcp = FastMCP(name="ContextDemo")

@mcp.tool
async def process_data(data_uri: str, ctx: Context) -> dict:
    """从资源处理数据并报告进度。"""
    await ctx.info(f"正在处理来自 {data_uri} 的数据")
    
    # 读取资源
    resource = await ctx.read_resource(data_uri)
    data = resource[0].content if resource else ""
    
    # 报告进度
    await ctx.report_progress(progress=50, total=100)
    
    # 向客户端的 LLM 请求帮助的示例
    summary = await ctx.sample(f"用10个词总结这个：{data[:200]}")
    
    await ctx.report_progress(progress=100, total=100)
    return {
        "length": len(data),
        "summary": summary.text
    }
```

Context 对象提供对以下功能的访问：

- **日志记录**：`ctx.debug()`、`ctx.info()`、`ctx.warning()`、`ctx.error()`
- **进度报告**：`ctx.report_progress(progress, total)`
- **资源访问**：`ctx.read_resource(uri)`
- **LLM 采样**：`ctx.sample(...)`
- **请求信息**：`ctx.request_id`、`ctx.client_id`

有关 Context 对象及其所有功能的完整文档，请参阅[上下文文档](/zh/servers/context)。

## 参数类型

FastMCP 支持多种参数类型，为您设计工具时提供灵活性。

FastMCP 通常支持 Pydantic 作为字段支持的所有类型，包括所有 Pydantic 自定义类型。这意味着您可以在工具参数中使用任何可以由 Pydantic 验证和解析的类型。

FastMCP 在可能的情况下支持**类型强制转换**。这意味着如果客户端发送的数据不匹配预期类型，FastMCP 将尝试将其转换为适当的类型。例如，如果客户端为注解为 `int` 的参数发送字符串，FastMCP 将尝试将其转换为整数。如果转换失败，FastMCP 将返回验证错误。

### 内置类型

最常见的参数类型是 Python 的内置标准类型：

```python
@mcp.tool
def process_values(
    name: str,             # 文本数据
    count: int,            # 整数
    amount: float,         # 浮点数
    enabled: bool          # 布尔值（True/False）
):
    """处理各种值类型。"""
    # 具体实现...
```

这些类型向 LLM 提供关于什么值是期望的并且可接受的，并允许 FastMCP 正确验证输入。即使客户端提供像"42"这样的字符串，对于注解为 `int` 的参数，它也会被强制转换为整数。

### 日期和时间类型

FastMCP 支持来自 `datetime` 模块的各种日期和时间类型：

```python
from datetime import datetime, date, timedelta

@mcp.tool
def process_date_time(
    event_date: date,             # ISO 格式日期字符串或 date 对象
    event_time: datetime,         # ISO 格式日期时间字符串或 datetime 对象
    duration: timedelta = timedelta(hours=1)  # 整数秒或 timedelta 对象
) -> str:
    """处理日期和时间信息。"""
    # 类型会自动从字符串转换
    assert isinstance(event_date, date)  
    assert isinstance(event_time, datetime)
    assert isinstance(duration, timedelta)
    
    return f"事件在 {event_date} 的 {event_time} 持续 {duration}"
```

- `datetime` - 接受 ISO 格式字符串（例如，"2023-04-15T14:30:00"）
- `date` - 接受 ISO 格式日期字符串（例如，"2023-04-15"）
- `timedelta` - 接受整数秒或 timedelta 对象

### 集合类型

FastMCP 支持所有标准 Python 集合类型：

```python
@mcp.tool
def analyze_data(
    values: list[float],           # 数字列表
    properties: dict[str, str],    # 具有字符串键和值的字典
    unique_ids: set[int],          # 唯一整数集合
    coordinates: tuple[float, float],  # 具有固定结构的元组
    mixed_data: dict[str, list[int]] # 嵌套集合
):
    """分析数据集合。"""
    # 具体实现...
```

所有集合类型都可以用作参数注解：
- `list[T]` - 有序项目序列
- `dict[K, V]` - 键值映射
- `set[T]` - 唯一项目的无序集合
- `tuple[T1, T2, ...]` - 可能具有不同类型的固定长度序列

集合类型可以嵌套和组合以表示复杂的数据结构。符合预期结构的 JSON 字符串将自动解析并转换为适当的 Python 集合类型。

### 联合(Union)和可选(Optional)类型

对于可以接受多种类型或可能被省略的参数：

```python
@mcp.tool
def flexible_search(
    query: str | int,              # 可以是字符串或整数
    filters: dict[str, str] | None = None,  # 可选字典
    sort_field: str | None = None  # 可选字符串
):
    """使用灵活参数类型进行搜索。"""
    # 具体实现...
```

现代 Python 语法（`str | int`）优于较旧的 `Union[str, int]` 形式。同样，`str | None` 优于 `Optional[str]`。

### 约束类型

当参数必须是预定义值集合中的一个时，您可以使用 Literal 类型或 Enums：

#### 字面量(Literal)

字面量将参数限制为特定值集合：

```python
from typing import Literal

@mcp.tool
def sort_data(
    data: list[float],
    order: Literal["ascending", "descending"] = "ascending",
    algorithm: Literal["quicksort", "mergesort", "heapsort"] = "quicksort"
):
    """使用特定选项对数据进行排序。"""
    # 实现...
```

字面量类型：
- 直接在类型注解中指定确切的允许值
- 帮助 LLM 准确理解哪些值是可接受的
- 提供输入验证（对无效值产生错误）
- 为客户端创建清晰的数据结构

#### 枚举(Enums)

对于更结构化的约束值集合，使用 Python 的 Enum 类：

```python
from enum import Enum

class Color(Enum):
    RED = "red"
    GREEN = "green"
    BLUE = "blue"

@mcp.tool
def process_image(
    image_path: str, 
    color_filter: Color = Color.RED
):
    """使用颜色滤镜处理图像。"""
    # 实现...
    # color_filter 将是一个 Color 枚举成员
```

使用枚举类型时：
- 客户端应提供枚举的值（例如，"red"），而不是枚举成员名称（例如，"RED"）
- FastMCP 自动将字符串值强制转换为适当的枚举对象
- 您的函数接收实际的枚举成员（例如，`Color.RED`）
- 对于不在枚举中的值将引发验证错误

### 二进制数据

在工具参数中处理二进制数据有两种方法：

#### 字节(Bytes)

```python
@mcp.tool
def process_binary(data: bytes):
    """直接处理二进制数据。
    
    客户端可以发送二进制字符串，它将直接转换为字节。
    """
    # 使用二进制数据的实现
    data_length = len(data)
    # ...
```

当您将参数注解为 `bytes` 时，FastMCP 将：
- 直接将原始字符串转换为字节
- 验证输入可以正确表示为字节

FastMCP 不会自动为字节参数解码 base64 编码的字符串。如果您需要接受 base64 编码的数据，应如下所示手动处理解码。

#### Base64 编码字符串

```python
from typing import Annotated
from pydantic import Field

@mcp.tool
def process_image_data(
    image_data: Annotated[str, Field(description="Base64编码的图像数据")]
):
    """从 base64 编码字符串处理图像。
    
    期望客户端以字符串形式提供 base64 编码的数据。
    您需要手动解码它。
    """
    # 手动 base64 解码
    import base64
    binary_data = base64.b64decode(image_data)
    # 处理 binary_data...
```

当您期望从客户端接收 base64 编码的二进制数据时，建议使用这种方法。

### 路径

来自 `pathlib` 模块的 `Path` 类型可用于文件系统路径：

```python
from pathlib import Path

@mcp.tool
def process_file(path: Path) -> str:
    """处理给定路径的文件。"""
    assert isinstance(path, Path)  # Path 已正确转换
    return f"正在处理文件：{path}"
```

当客户端发送字符串路径时，FastMCP 会自动将其转换为 `Path` 对象。

### UUIDs

来自 `uuid` 模块的 `UUID` 类型可用于唯一标识符：

```python
import uuid

@mcp.tool
def process_item(
    item_id: uuid.UUID  # 字符串 UUID 或 UUID 对象
) -> str:
    """处理具有给定 UUID 的项目。"""
    assert isinstance(item_id, uuid.UUID)  # 已正确转换为 UUID
    return f"正在处理项目 {item_id}"
```

当客户端发送字符串 UUID（例如，"123e4567-e89b-12d3-a456-426614174000"）时，FastMCP 会自动将其转换为 `UUID` 对象。

### Pydantic 模型

对于具有嵌套字段和验证的复杂结构化数据，使用 Pydantic 模型：

```python
from pydantic import BaseModel, Field
from typing import Optional

class User(BaseModel):
    username: str
    email: str = Field(description="用户的电子邮件地址")
    age: int | None = None
    is_active: bool = True

@mcp.tool
def create_user(user: User):
    """在系统中创建新用户。"""
    # 输入会自动根据 User 模型进行验证
    # 即使以 JSON 字符串或字典形式提供
    # 实现...
```

使用 Pydantic 模型提供：
- 复杂输入的清晰、自文档化结构
- 内置数据验证
- 为 LLM 自动生成详细的 JSON 架构
- 从 dict/JSON 输入自动转换

客户端可以为 Pydantic 模型参数提供以下任一形式的数据：
- JSON 对象（字符串）
- 具有适当结构的字典
- 适当格式的嵌套参数

### Pydantic Fields

FastMCP 通过 Pydantic 的 `Field` 类支持强大的参数验证。这对于确保输入值满足除类型之外的特定要求特别有用。

注意，字段可以在 Pydantic 模型*之外*使用，以提供元数据和验证约束。首选方法是将 `Annotated` 与 `Field` 一起使用：

```python
from typing import Annotated
from pydantic import Field

@mcp.tool
def analyze_metrics(
    # 具有范围约束的数字
    count: Annotated[int, Field(ge=0, le=100)],         # 0 <= count <= 100
    ratio: Annotated[float, Field(gt=0, lt=1.0)],       # 0 < ratio < 1.0
    
    # 具有模式和长度约束的字符串
    user_id: Annotated[str, Field(
        pattern=r"^[A-Z]{2}\d{4}$",                     # 必须匹配正则表达式模式
        description="格式为 XX0000 的用户 ID"
    )],
    
    # 具有长度约束的字符串
    comment: Annotated[str, Field(min_length=3, max_length=500)] = "",
    
    # 数字约束
    factor: Annotated[int, Field(multiple_of=5)] = 10,  # 必须是 5 的倍数
):
    """使用验证参数分析指标。"""
    # 实现...
```

您也可以将 `Field` 用作默认值，尽管首选 `Annotated` 方法：

```python
@mcp.tool
def validate_data(
    # 值约束
    age: int = Field(ge=0, lt=120),                     # 0 <= age < 120
    
    # 字符串约束
    email: str = Field(pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$"),  # 电子邮件模式
    
    # 集合约束
    tags: list[str] = Field(min_length=1, max_length=10)  # 1-10 个标签
):
    """使用字段验证处理数据。"""
    # 实现...
```

常见的验证选项包括：

| 验证 | 类型 | 描述 |
| :--------- | :--- | :---------- |
| `ge`, `gt` | 数字 | 大于（或等于）约束 |
| `le`, `lt` | 数字 | 小于（或等于）约束 |
| `multiple_of` | 数字 | 值必须是此数字的倍数 |
| `min_length`, `max_length` | 字符串、列表等 | 长度约束 |
| `pattern` | 字符串 | 正则表达式模式约束 |
| `description` | 任何 | 人类可读的描述（出现在Schema中） |

当客户端发送无效数据时，FastMCP 将返回验证错误，并解释参数验证失败的原因。

## Server行为

### 重复工具

<VersionBadge version="2.1.0" />

您可以控制当您尝试注册具有相同名称的多个工具时 FastMCP 服务的行为。这是在创建 `FastMCP` 实例时使用 `on_duplicate_tools` 参数配置的。

```python
from fastmcp import FastMCP

mcp = FastMCP(
    name="StrictServer",
    # 配置重复工具名称的行为
    on_duplicate_tools="error"
)

@mcp.tool
def my_tool(): return "Version 1"

# 这现在会引发 ValueError，因为 'my_tool' 已经存在
# 并且 on_duplicate_tools 设置为 "error"。
# @mcp.tool
# def my_tool(): return "Version 2"
```

重复行为选项包括：

-   `"warn"`（默认）：记录警告，新工具替换旧工具。
-   `"error"`：引发 `ValueError`，阻止重复注册。
-   `"replace"`：静默替换现有工具为新工具。
-   `"ignore"`：保留原始工具并忽略新的注册尝试。

### 移除工具

<VersionBadge version="2.3.4" />

您可以使用 `remove_tool` 方法从服务端动态移除工具：

```python
from fastmcp import FastMCP

mcp = FastMCP(name="DynamicToolServer")

@mcp.tool
def calculate_sum(a: int, b: int) -> int:
    """将两个数字相加。"""
    return a + b

mcp.remove_tool("calculate_sum")
```
