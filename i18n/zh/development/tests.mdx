---
title: "测试"
description: "FastMCP 的测试模式和要求"
icon: vial
---

良好的测试是可靠软件的基础。在 FastMCP 中，我们将测试视为一流的文档，展示功能如何工作的同时防止回归。每个新功能都需要全面的测试来证明正确性。

## FastMCP 测试

### 运行测试

```bash
# 运行所有测试
uv run pytest

# 运行特定测试文件
uv run pytest tests/server/test_auth.py

# 带覆盖率运行
uv run pytest --cov=fastmcp

# 跳过集成测试以加快运行速度
uv run pytest -m "not integration"

# 跳过生成进程的测试
uv run pytest -m "not integration and not client_process"
```

测试应该在 1 秒内完成，除非标记为集成测试。这种速度鼓励频繁运行，及早发现问题。

### 测试组织

我们的测试组织反映了 `src/` 目录结构，在代码和测试之间创建可预测的映射。当您处理 `src/fastmcp/server/auth.py` 时，您会在 `tests/server/test_auth.py` 中找到它的测试。在少数情况下，测试会进一步分割 - 例如，OpenAPI 测试非常全面，分布在多个文件中。

### 测试标记

我们使用 pytest 标记来分类需要特殊资源或运行时间较长的测试：

```python
@pytest.mark.integration
async def test_github_api_integration():
    """测试与真实服务的 GitHub API 集成。"""
    token = os.getenv("FASTMCP_GITHUB_TOKEN")
    if not token:
        pytest.skip("FASTMCP_GITHUB_TOKEN 不可用")
    
    # 对真实的 GitHub API 进行测试
    client = GitHubClient(token)
    repos = await client.list_repos("jlowin")
    assert "fastmcp" in [repo.name for repo in repos]

@pytest.mark.client_process
async def test_stdio_transport():
    """测试单独进程的 STDIO 传输。"""
    # 这会生成一个子进程
    async with Client("python examples/simple_echo.py") as client:
        result = await client.call_tool("echo", {"message": "test"})
        assert result.content[0].text == "test"
```

## 编写测试


### 测试要求

遵循这些实践可以创建可维护、可调试的测试套件，既作为文档又作为回归保护。

#### 每个测试一个行为

每个测试应该验证确切的一个行为。当它失败时，您需要立即知道什么坏了。一个检查五件事的测试给您五个潜在的故障点需要调查。一个检查一件事的测试直接指向问题。

<CodeGroup>

```python 好：原子测试
async def test_tool_registration():
    """测试工具是否正确注册到服务器。"""
    mcp = FastMCP("test-server")
    
    @mcp.tool
    def add(a: int, b: int) -> int:
        return a + b
    
    tools = mcp.list_tools()
    assert len(tools) == 1
    assert tools[0].name == "add"
```

```python 差：多行为测试
async def test_server_functionality():
    """一次测试多个服务器功能。"""
    mcp = FastMCP("test-server")
    
    # 工具注册
    @mcp.tool
    def add(a: int, b: int) -> int:
        return a + b
    
    # 资源创建
    @mcp.resource("config://app")
    def get_config():
        return {"version": "1.0"}
    
    # 身份验证设置
    mcp.auth = BearerTokenProvider({"token": "user"})
    
    # 我们到底在测试什么？如果失败，什么坏了？
    assert mcp.list_tools()
    assert mcp.list_resources()
    assert mcp.auth is not None
```

</CodeGroup>

#### 自包含设置

每个测试都必须创建自己的设置。测试应该能够以任何顺序、并行或隔离运行。当测试失败时，您应该能够仅运行该测试来重现问题。

<CodeGroup>

```python 好：自包含
async def test_tool_execution_with_error():
    """测试工具错误是否正确处理。"""
    mcp = FastMCP("test-server")
    
    @mcp.tool
    def divide(a: int, b: int) -> float:
        if b == 0:
            raise ValueError("不能除以零")
        return a / b
    
    async with Client(mcp) as client:
        with pytest.raises(Exception):
            await client.call_tool("divide", {"a": 10, "b": 0})
```

```python 差：测试依赖
# 测试依赖的全局状态
test_server = None

def test_setup_server():
    """为其他测试设置。"""
    global test_server
    test_server = FastMCP("shared-server")

def test_server_works():
    """测试服务器功能。"""
    # 依赖于 test_setup_server 首先运行
    assert test_server is not None
```

</CodeGroup>

#### 明确意图

测试名称和断言应该使验证的行为显而易见。阅读您的测试的开发者应该理解它验证什么功能以及该功能应该如何表现。

```python
async def test_authenticated_tool_requires_valid_token():
    """测试已认证用户可以访问受保护的工具。"""
    mcp = FastMCP("test-server")
    mcp.auth = BearerTokenProvider({"secret-token": "test-user"})
    
    @mcp.tool
    def protected_action() -> str:
        return "成功"
    
    async with Client(mcp, auth=BearerAuth("secret-token")) as client:
        result = await client.call_tool("protected_action", {})
        assert result.content[0].text == "成功"
```

#### 使用 Fixtures

使用 fixtures 为您的测试创建可重用的数据、服务器配置或其他资源。请注意，您**不应该**在 fixtures 中打开 FastMCP 客户端，因为这可能会创建难以诊断的事件循环问题。

```python
import pytest
from fastmcp import FastMCP, Client

@pytest.fixture
def weather_server():
    server = FastMCP("WeatherServer")
    
    @server.tool
    def get_temperature(city: str) -> dict:
        temps = {"NYC": 72, "LA": 85, "Chicago": 68}
        return {"city": city, "temp": temps.get(city, 70)}
    
    return server

async def test_temperature_tool(weather_server):
    async with Client(weather_server) as client:
        result = await client.call_tool("get_temperature", {"city": "LA"})
        assert result.data == {"city": "LA", "temp": 85}
```

#### 有效断言

断言应该是具体的，并在失败时提供上下文。当测试在 CI 期间失败时，断言消息应该告诉您究竟出了什么问题。

```python
# 基本断言 - 失败时上下文最少
assert result.status == "success"

# 更好 - 解释期望的内容
assert result.status == "success", f"期望成功操作，得到 {result.status}: {result.error}"
```

尽量不要在单个测试中有太多断言，除非您真的需要检查同一行为的各个方面。一般来说，不同行为的断言应该在单独的测试中。

#### 内联快照

FastMCP采用`inline-snapshot`来测试复杂数据结构。首次运行`pytest --inline-snapshot=create`且`snapshot()`为空时，pytest会自动填充预期值。若需在有意修改后更新快照，请运行`pytest --inline-snapshot=fix`。此方法对测试JSON schema和API响应特别有效。

```python
from inline_snapshot import snapshot

async def test_tool_schema_generation():
    """测试工具 schemas 是否正确生成。"""
    mcp = FastMCP("test-server")
    
    @mcp.tool
    def calculate_tax(amount: float, rate: float = 0.1) -> dict:
        """计算金额的税款。"""
        return {"amount": amount, "tax": amount * rate, "total": amount * (1 + rate)}
    
    tools = mcp.list_tools()
    schema = tools[0].inputSchema
    
    # 第一次运行：snapshot() 为空，自动填充
    # 后续运行：与存储的快照比较
    assert schema == snapshot({
        "type": "object", 
        "properties": {
            "amount": {"type": "number"}, 
            "rate": {"type": "number", "default": 0.1}
        }, 
        "required": ["amount"]
    })
```

### 内存测试

FastMCP 使用内存传输进行测试，其中服务器和客户端直接通信。大部分功能都可以以这种确定性方式进行测试。我们只在测试传输本身时使用更复杂的设置。

内存传输运行真实的 MCP 协议实现，没有网络开销。无需部署服务器或管理网络连接，您可以直接将服务器实例传递给客户端。一切都在同一个 Python 进程中运行 - 您可以在任何地方设置断点并使用调试器逐步执行。

```python
from fastmcp import FastMCP, Client

# 创建您的服务器
server = FastMCP("WeatherServer")

@server.tool
def get_temperature(city: str) -> dict:
    """获取城市的当前温度"""
    temps = {"NYC": 72, "LA": 85, "Chicago": 68}
    return {"city": city, "temp": temps.get(city, 70)}

async def test_weather_operations():
    # 直接传递服务器 - 无需部署
    async with Client(server) as client:
        result = await client.call_tool("get_temperature", {"city": "NYC"})
        assert result.data == {"city": "NYC", "temp": 72}
```

这种模式使测试具有确定性和快速性 - 通常在毫秒而不是秒内完成。

### 模拟外部依赖

FastMCP 服务器是标准的 Python 对象，因此您可以使用您偏好的方法模拟外部依赖：

```python
from unittest.mock import AsyncMock

async def test_database_tool():
    server = FastMCP("DataServer")
    
    # 模拟数据库
    mock_db = AsyncMock()
    mock_db.fetch_users.return_value = [
        {"id": 1, "name": "Alice"},
        {"id": 2, "name": "Bob"}
    ]
    
    @server.tool
    async def list_users() -> list:
        return await mock_db.fetch_users()
    
    async with Client(server) as client:
        result = await client.call_tool("list_users", {})
        assert len(result.data) == 2
        assert result.data[0]["name"] == "Alice"
        mock_db.fetch_users.assert_called_once()
```

### 测试网络传输

虽然内存测试涵盖了大部分单元测试需求，但您偶尔需要测试实际的网络传输。使用 `run_server_in_process` 实用程序在单独的进程中生成服务器进行测试：

```python
import pytest
from fastmcp.utilities.tests import run_server_in_process
from fastmcp import FastMCP, Client
from fastmcp.client.transports import StreamableHttpTransport

def run_server(host: str, port: int) -> None:
    """在子进程中运行的函数。"""
    server = FastMCP("TestServer")
    
    @server.tool
    def greet(name: str) -> str:
        return f"你好，{name}！"
    
    server.run(host=host, port=port)

@pytest.fixture
async def http_server():
    """在子进程中运行服务器的 fixture。"""
    with run_server_in_process(run_server, transport="http") as url:
        yield f"{url}/mcp"

async def test_http_transport(http_server: str):
    """测试实际的 HTTP 传输行为。"""
    async with Client(
        transport=StreamableHttpTransport(http_server)
    ) as client:
        result = await client.ping()
        assert result is True
        
        greeting = await client.call_tool("greet", {"name": "World"})
        assert greeting.data == "你好，World！"
```

`run_server_in_process` 实用程序自动处理服务器生命周期、端口分配和清理。这种模式对于测试传输特定行为（如超时、标头和身份验证）至关重要。请注意，FastMCP 经常使用 `client_process` 标记来隔离生成进程的测试，因为它们可能在 CI 中创建争用。

### 文档测试

文档需要与代码相同的验证。`just docs` 命令启动一个本地 Mintlify 服务器，完全按照用户看到的方式渲染您的文档：

```bash
# 启动带热重载的本地文档服务器
just docs

# 或直接运行 Mintlify
mintlify dev
```

本地服务器监视更改并自动刷新。此预览捕获格式问题并帮助您看到用户将体验到的文档。