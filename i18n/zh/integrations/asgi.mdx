---
title: ASGI / Starlette 🤝 FastMCP
sidebarTitle: ASGI / Starlette
description: 将 FastMCP 服务器集成到 ASGI 应用程序中
icon: server
---

import { VersionBadge } from '/snippets/version-badge.mdx'

<VersionBadge version="2.3.1" />

FastMCP 服务器可以集成到现有的 ASGI 应用程序中，允许您为 Web 应用程序添加 MCP 功能。这对以下情况很有用：

- 为现有网站或 API 添加 MCP 功能
- 在特定 URL 路径下挂载 MCP 服务器
- 在单个应用程序中组合多个服务
- 利用现有的身份验证和中间件

## 基本用法

要将 FastMCP 服务器集成到 ASGI 应用程序中，请使用 `http_app()` 方法获取 Starlette 应用程序实例：

<Tip>
`http_app()` 方法是 FastMCP 2.3.2 中的新功能。在旧版本中，请使用 `sse_app()` 进行 SSE 传输或使用 `streamable_http_app()` 进行 Streamable HTTP 传输。
</Tip>

```python
from fastmcp import FastMCP

mcp = FastMCP("MyServer")

@mcp.tool
def hello(name: str) -> str:
    return f"Hello, {name}!"

# 获取 Streamable HTTP 传输的 Starlette 应用实例（推荐）
http_app = mcp.http_app()

# 用于传统 SSE 传输（已弃用）
sse_app = mcp.http_app(transport="sse")
```

返回的 Starlette 应用程序可以与其他兼容 ASGI 的 Web 框架集成。MCP 服务器的端点在 Streamable HTTP 传输中挂载在 `/mcp/`，在 SSE 传输中挂载在 `/sse/`。

### 配置选项

您可以自定义端点路径并访问 FastMCP 服务器实例：

```python
# 自定义端点路径
http_app = mcp.http_app(path="/custom-mcp-path")

# 从中间件/路由访问 FastMCP 服务器
# 服务器可在此处访问：request.app.state.fastmcp_server
```

### 添加自定义路由

您可以使用 `@custom_route` 装饰器直接将自定义 Web 路由添加到您的 FastMCP 服务器：

```python
from fastmcp import FastMCP
from starlette.requests import Request
from starlette.responses import JSONResponse

mcp = FastMCP("MyServer")

@mcp.custom_route("/api/status", methods=["GET"])
async def get_status(request: Request):
    return JSONResponse({"server": "running"})

http_app = mcp.http_app()
```

#### 健康检查端点

健康检查通常用于监控和负载均衡：

```python
from fastmcp import FastMCP
from starlette.requests import Request
from starlette.responses import JSONResponse

mcp = FastMCP("MyServer")

@mcp.custom_route("/health", methods=["GET"])
async def health_check(request: Request):
    return JSONResponse({"status": "healthy"})

http_app = mcp.http_app()
```

健康端点将在 `/health` 可用，与您在 `/mcp/` 的 MCP 端点一起。

## Starlette 集成

在另一个 Starlette 应用程序中挂载您的 FastMCP 服务器：

```python
from fastmcp import FastMCP
from starlette.applications import Starlette
from starlette.routing import Mount

# 创建您的 FastMCP 服务器
mcp = FastMCP("MyServer")

@mcp.tool
def analyze(data: str) -> dict:
    return {"result": f"Analyzed: {data}"}

# 创建 ASGI 应用
mcp_app = mcp.http_app(path='/mcp')

# 创建 Starlette 应用并挂载 MCP 服务器
app = Starlette(
    routes=[
        Mount("/mcp-server", app=mcp_app),
        # 按需添加其他路由
    ],
    lifespan=mcp_app.lifespan,
)
```

MCP 端点将在结果 Starlette 应用程序的 `/mcp-server/mcp/` 处可用。

<Warning>
对于 Streamable HTTP 传输，您**必须**将生命周期上下文从 FastMCP 应用传递到结果 Starlette 应用，因为嵌套的生命周期不被识别。否则，FastMCP 服务器的会话管理器将不会正确初始化。
</Warning>

### 嵌套挂载

您可以通过嵌套挂载创建复杂的路由结构：

```python
from fastmcp import FastMCP
from starlette.applications import Starlette
from starlette.routing import Mount

# 创建您的 FastMCP 服务器
mcp = FastMCP("MyServer")

# 创建 ASGI 应用
mcp_app = mcp.http_app(path='/mcp')

# 创建嵌套应用结构
inner_app = Starlette(routes=[Mount("/inner", app=mcp_app)])
app = Starlette(
    routes=[Mount("/outer", app=inner_app)],
    lifespan=mcp_app.lifespan,
)
```

在此设置中，MCP 服务器可在 `/outer/inner/mcp/` 路径访问。

## 自定义中间件

<VersionBadge version="2.3.2" />

通过传递中间件实例列表，将自定义 Starlette 中间件添加到您的 FastMCP ASGI 应用程序：

```python
from fastmcp import FastMCP
from starlette.middleware import Middleware
from starlette.middleware.cors import CORSMiddleware

# 创建您的 FastMCP 服务器
mcp = FastMCP("MyServer")

# 定义自定义中间件
custom_middleware = [
    Middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
    )
]

# 使用中间件创建 ASGI 应用
http_app = mcp.http_app(custom_middleware=custom_middleware)
```

## 运行服务器

要运行您的 ASGI 应用程序，请使用像 `uvicorn` 这样的 ASGI 服务器：

```python
import uvicorn

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

或者从命令行：

```bash
uvicorn path.to.your.app:app --host 0.0.0.0 --port 8000
```

## 框架特定集成

### FastAPI

有关 FastAPI 特定的集成模式（包括将 MCP 服务器挂载到 FastAPI 应用和从 FastAPI 应用生成 MCP 服务器），请参见 [FastAPI 集成指南](/zh/integrations/fastapi)。

### 其他 ASGI 框架

这里显示的模式适用于任何兼容 ASGI 的框架。关键要求是：

1. 在您所需的路径上挂载 FastMCP ASGI 应用
2. 将生命周期上下文传递给您的根应用程序
3. 配置任何必要的中间件或身份验证

