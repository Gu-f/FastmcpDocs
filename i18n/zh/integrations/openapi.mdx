---
title: OpenAPI 🤝 FastMCP
sidebarTitle: OpenAPI
description: 从任何 OpenAPI 规范生成 MCP 服务器
icon: list-tree
---

import { VersionBadge } from '/snippets/version-badge.mdx'

<VersionBadge version="2.0.0" />

<Tip>
**2.11 中的新功能**：FastMCP 正在引入下一代 OpenAPI 解析器。新解析器在性能和兼容性方面大幅改进，也更容易维护。要启用它，请设置环境变量 `FASTMCP_EXPERIMENTAL_ENABLE_NEW_OPENAPI_PARSER=true`。

新解析器在 API 方面与现有实现大体兼容，并将在未来版本中成为默认选项。我们鼓励所有用户在它成为默认选项之前测试它并报告任何问题。
</Tip>

FastMCP 可以从任何 OpenAPI 规范自动生成 MCP 服务器，允许 AI 模型通过 MCP 协议与现有 API 交互。无需手动创建工具和资源，您只需提供 OpenAPI 规范，FastMCP 就会智能地将 API 端点转换为适当的 MCP 组件。

<Tip>
从 OpenAPI 生成 MCP 服务器是开始使用 FastMCP 的好方法，但在实践中，精心设计和精心制作的 MCP 服务器比自动转换的 OpenAPI 服务器在 LLM 上实现**显著更好的性能**。对于具有许多端点和参数的复杂 API，这一点尤其如此。

我们建议使用 FastAPI 集成进行引导和原型设计，而不是将您的 API 镜像给 LLM 客户端。有关更多详细信息，请参阅文章 [停止将您的 REST API 转换为 MCP](https://www.jlowin.dev/blog/stop-converting-rest-apis-to-mcp)。
</Tip>

## 创建服务器

要将 OpenAPI 规范转换为 MCP 服务器，请使用 `FastMCP.from_openapi()` 类方法：

```python server.py
import httpx
from fastmcp import FastMCP

# 为您的 API 创建 HTTP 客户端
client = httpx.AsyncClient(base_url="https://api.example.com")

# 加载您的 OpenAPI 规范
openapi_spec = httpx.get("https://api.example.com/openapi.json").json()

# 创建 MCP 服务器
mcp = FastMCP.from_openapi(
    openapi_spec=openapi_spec,
    client=client,
    name="我的 API 服务器"
)

if __name__ == "__main__":
    mcp.run()
```

### 身份验证

如果您的 API 需要身份验证，请在 HTTP 客户端上进行配置：

```python
import httpx
from fastmcp import FastMCP

# Bearer 令牌身份验证
api_client = httpx.AsyncClient(
    base_url="https://api.example.com",
    headers={"Authorization": "Bearer YOUR_TOKEN"}
)

# 使用经过身份验证的客户端创建 MCP 服务器
mcp = FastMCP.from_openapi(
    openapi_spec=spec, 
    client=api_client,
    timeout=30.0  # 所有请求的 30 秒超时
)
```

## 路由映射

默认情况下，FastMCP 将 OpenAPI 规范中的**每个端点**转换为 MCP **工具**。这提供了一个简单、可预测的起点，确保您的 API 的所有功能对绝大多数仅支持 MCP 工具的 LLM 客户端立即可用。

虽然这是为了最大兼容性的实用默认设置，但您可以轻松地自定义此行为。在内部，FastMCP 使用有序的 `RouteMap` 对象列表来确定如何将 OpenAPI 路由映射到各种 MCP 组件类型。

每个 `RouteMap` 指定方法、模式和标签的组合，以及相应的 MCP 组件类型。每个 OpenAPI 路由都会按顺序检查每个 `RouteMap`，第一个匹配所有条件的将用于确定其转换的 MCP 类型。特殊类型 `EXCLUDE` 可用于完全从 MCP 服务器中排除路由。

- **方法**：要匹配的 HTTP 方法（例如 `["GET", "POST"]` 或 `"*"` 表示全部）
- **模式**：用于匹配路由路径的正则表达式模式（例如 `r"^/users/.*"` 或 `r".*"` 表示全部）
- **标签**：必须全部存在的 OpenAPI 标签集。空集合（`{}`）意味着没有标签过滤，因此路由不管其标签如何都会匹配
- **MCP 类型**：要创建的 MCP 组件类型（`TOOL`、`RESOURCE`、`RESOURCE_TEMPLATE` 或 `EXCLUDE`）
- **MCP 标签**：要添加到从匹配路由创建的组件的自定义标签集

以下是 FastMCP 的默认规则：

```python
from fastmcp.server.openapi import RouteMap, MCPType

DEFAULT_ROUTE_MAPPINGS = [
    # 所有路由都成为工具
    RouteMap(mcp_type=MCPType.TOOL),
]
```

<Tip>
**实验性解析器**：如果您使用的是新解析器（通过 `FASTMCP_EXPERIMENTAL_ENABLE_NEW_OPENAPI_PARSER=true` 启用），请从实验模块导入：
```python
from fastmcp.experimental.server.openapi import RouteMap, MCPType
```
API 是相同的，但实现提供了更好的性能和无服务器兼容性。
</Tip>

### 自定义路由映射

在创建 FastMCP 服务器时，您可以通过提供自己的 `RouteMap` 对象列表来自定义路由行为。您的自定义映射在默认路由映射之前处理，路由将被分配给第一个匹配的自定义映射。

例如，在 FastMCP 2.8.0 之前，GET 请求根据是否具有路径参数自动映射到 `Resource` 和 `ResourceTemplate` 组件。（这仅仅是为了客户端兼容性原因而改变的。）您可以通过提供自定义路由映射来恢复此行为：

```python
from fastmcp import FastMCP
from fastmcp.server.openapi import RouteMap, MCPType

# 恢复 2.8.0 之前的语义映射
semantic_maps = [
    # 带有路径参数的 GET 请求成为 ResourceTemplates
    RouteMap(methods=["GET"], pattern=r".*\{.*\}.*", mcp_type=MCPType.RESOURCE_TEMPLATE),
    # 所有其他 GET 请求成为 Resources
    RouteMap(methods=["GET"], pattern=r".*", mcp_type=MCPType.RESOURCE),
]

mcp = FastMCP.from_openapi(
    openapi_spec=spec,
    client=client,
    route_maps=semantic_maps,
)
```

使用这些映射，`GET` 请求会被语义化处理，所有其他方法（`POST`、`PUT` 等）将转入默认规则并成为 `Tool`。

以下是一个更完整的示例，使用自定义路由映射将 `/analytics/` 下的所有 `GET` 端点转换为工具，同时排除所有管理员端点和所有标记为“internal”的路由。所有其他路由将由默认规则处理：

```python
from fastmcp import FastMCP
from fastmcp.server.openapi import RouteMap, MCPType

mcp = FastMCP.from_openapi(
    openapi_spec=spec,
    client=client,
    route_maps=[
        # 分析 `GET` 端点是工具
        RouteMap(
            methods=["GET"], 
            pattern=r"^/analytics/.*", 
            mcp_type=MCPType.TOOL,
        ),

        # 排除所有管理员端点
        RouteMap(
            pattern=r"^/admin/.*", 
            mcp_type=MCPType.EXCLUDE,
        ),

        # 排除所有标记为 "internal" 的路由
        RouteMap(
            tags={"internal"},
            mcp_type=MCPType.EXCLUDE,
        ),
    ],
)
```

<Tip>
默认路由映射始终在您的自定义映射之后应用，因此您不必为每个可能的路由创建路由映射。
</Tip>

### 排除路由

要从 MCP 服务器中排除路由，请使用路由映射将它们分配给 `MCPType.EXCLUDE`。

您可以使用此方法通过具体针对敏感或内部路由来删除它们：

```python
from fastmcp import FastMCP
from fastmcp.server.openapi import RouteMap, MCPType

mcp = FastMCP.from_openapi(
    openapi_spec=spec,
    client=client,
    route_maps=[
        RouteMap(pattern=r"^/admin/.*", mcp_type=MCPType.EXCLUDE),
        RouteMap(tags={"internal"}, mcp_type=MCPType.EXCLUDE),
    ],
)
```

或者您可以使用通配规则来排除您的映射未明确处理的所有内容：

```python
from fastmcp import FastMCP
from fastmcp.server.openapi import RouteMap, MCPType

mcp = FastMCP.from_openapi(
    openapi_spec=spec,
    client=client,
    route_maps=[
        # 自定义映射逻辑在这里
        # ... 您的具体路由映射 ...
        # 排除所有剩余路由
        RouteMap(mcp_type=MCPType.EXCLUDE),
    ],
)
```

<Tip>
使用通配排除规则将阻止应用默认路由映射，因为它将匹配每个剩余路由。如果您想要明确允许列表特定路由，这很有用。
</Tip>

### 高级路由映射

<VersionBadge version="2.5.0" />

对于需要更复杂逻辑的高级用例，您可以提供 `route_map_fn` 可调用对象。在应用路由映射逻辑后，此函数在每个匹配的路由及其分配的 MCP 组件类型上被调用。它可以选择性地返回不同的组件类型来覆盖映射分配。如果它返回 `None`，则使用分配的类型。

除了更精确地针对方法、模式和标签之外，此函数还可以访问有关路由的任何其他 OpenAPI 元数据。

<Tip>
`route_map_fn` **会**在在您的自定义映射中匹配 `MCPType.EXCLUDE` 的路由上被调用，让您有机会覆盖排除。
</Tip>

```python
from fastmcp import FastMCP
from fastmcp.server.openapi import RouteMap, MCPType, HTTPRoute

def custom_route_mapper(route: HTTPRoute, mcp_type: MCPType) -> MCPType | None:
    """高级路由类型映射。"""
    # 无论 HTTP 方法如何，将所有管理员路由转换为工具
    if "/admin/" in route.path:
        return MCPType.TOOL

    elif "internal" in route.tags:
        return MCPType.EXCLUDE
    
    # 即使是 POST，也将用户详细信息路由转换为模板
    elif route.path.startswith("/users/") and route.method == "POST":
        return MCPType.RESOURCE_TEMPLATE
    
    # 对所有其他路由使用默认值
    return None

mcp = FastMCP.from_openapi(
    openapi_spec=spec,
    client=client,
    route_map_fn=custom_route_mapper,
)
```

## 自定义

### 组件名称

<VersionBadge version="2.5.0" />

FastMCP 根据 OpenAPI 规范自动生成 MCP 组件的名称。默认情况下，它使用 OpenAPI 规范中的 `operationId`，直到第一个双下划线（`__`）。

所有组件名称都会自动：
- **缩略化**：空格和特殊字符被转换为下划线或删除
- **截断**：限制为最多 56 个字符以确保兼容性
- **唯一**：如果多个组件具有相同名称，会自动附加数字以使它们唯一

为了更好地控制组件名称，您可以提供一个 `mcp_names` 字典，将 `operationId` 值映射到您所需的名称。`operationId` 必须与在 OpenAPI 规范中显示的完全一致。提供的名称始终会被缩略化和截断。

```python
mcp = FastMCP.from_openapi(
    openapi_spec=spec,
    client=client,
    mcp_names={
        "list_users__with_pagination": "user_list",
        "create_user__admin_required": "create_user", 
        "get_user_details__admin_required": "user_detail",
    }
)
```

在 `mcp_names` 中找不到的任何 `operationId` 都将使用默认策略（operationId 直到第一个 `__`）。

### 标签

<VersionBadge version="2.8.0" />

FastMCP 提供了多种方式来向您的 MCP 组件添加标签，使您能够对它们进行分类和组织，以获得更好的可发现性和过滤。标签由多个来源组合，创建每个组件上的最终标签集。

#### RouteMap 标签

您可以使用 `RouteMap` 中的 `mcp_tags` 参数向从特定路由创建的组件添加自定义标签。这些标签将应用于从匹配该特定路由映射的路由创建的所有组件。

```python
from fastmcp.server.openapi import RouteMap, MCPType

mcp = FastMCP.from_openapi(
    openapi_spec=spec,
    client=client,
    route_maps=[
        # 向所有 POST 端点添加自定义标签
        RouteMap(
            methods=["POST"],
            pattern=r".*",
            mcp_type=MCPType.TOOL,
            mcp_tags={"write-operation", "api-mutation"}
        ),
        
        # 向详细视图端点添加不同标签
        RouteMap(
            methods=["GET"],
            pattern=r".*\{.*\}.*",
            mcp_type=MCPType.RESOURCE_TEMPLATE,
            mcp_tags={"detail-view", "parameterized"}
        ),
        
        # 向列表端点添加标签
        RouteMap(
            methods=["GET"],
            pattern=r".*",
            mcp_type=MCPType.RESOURCE,
            mcp_tags={"list-data", "collection"}
        ),
    ],
)
```

#### 全局标签

您可以在创建 MCP 服务器时提供 `tags` 参数来向**所有**组件添加标签。这些全局标签将应用于从 OpenAPI 规范创建的每个组件。

```python
mcp = FastMCP.from_openapi(
    openapi_spec=spec,
    client=client,
    tags={"api-v2", "production", "external"}
)
```

#### 客户端元数据中的 OpenAPI 标签

FastMCP 自动将您规范中的 OpenAPI 标签包含在组件的元数据中。这些标签通过 `_meta._fastmcp.tags` 字段对 MCP 客户端可用，允许客户端根据原始 OpenAPI 标记进行过滤和组织组件：

<CodeGroup>
```json {5} 带有标签的 OpenAPI 规范
{
  "paths": {
    "/users": {
      "get": {
        "tags": ["users", "public"],
        "operationId": "list_users",
        "summary": "列出所有用户"
      }
    }
  }
}
```
```python {6-9} 在 MCP 客户端中访问 OpenAPI 标签
async with client:
    tools = await client.list_tools()
    for tool in tools:
        if hasattr(tool, '_meta') and tool._meta:
            # OpenAPI 标签现在在 _fastmcp 命名空间中可用！
            fastmcp_meta = tool._meta.get('_fastmcp', {})
            openapi_tags = fastmcp_meta.get('tags', [])
            if 'users' in openapi_tags:
                print(f"找到与用户相关的工具：{tool.name}")
```
</CodeGroup>

这使客户端能够轻松地根据原始 OpenAPI 分类理解和组织 API 端点。

### 高级自定义

<VersionBadge version="2.5.0" />

默认情况下，FastMCP 使用 OpenAPI 规范中的各种元数据创建 MCP 组件，例如将 OpenAPI 描述合并到 MCP 组件描述中。

有时您可能希望以各种方式修改这些 MCP 组件，例如添加 LLM 特定指令或标签。对于精细的自定义，您可以在创建 MCP 服务器时提供 `mcp_component_fn`。在创建每个 MCP 组件后，此函数在其上被调用，并有机会就地修改它。

<Tip>
您的 `mcp_component_fn` 应该就地修改组件，而不是返回新组件。函数的结果被忽略。
</Tip>

```python
from fastmcp.server.openapi import (
    HTTPRoute, 
    OpenAPITool, 
    OpenAPIResource, 
    OpenAPIResourceTemplate,
)

# 如果使用实验性解析器，请从实验模块导入：
# from fastmcp.experimental.server.openapi import (
#     HTTPRoute,
#     OpenAPITool,
#     OpenAPIResource,
#     OpenAPIResourceTemplate,
# )

def customize_components(
    route: HTTPRoute, 
    component: OpenAPITool | OpenAPIResource | OpenAPIResourceTemplate,
) -> None:
    # 向所有组件添加自定义标签
    component.tags.add("openapi")
    
    # 根据组件类型进行自定义
    if isinstance(component, OpenAPITool):
        component.description = f"🔧 {component.description} (via API)"
    
    if isinstance(component, OpenAPIResource):
        component.description = f"📊 {component.description}"
        component.tags.add("data")

mcp = FastMCP.from_openapi(
    openapi_spec=spec,
    client=client,
    mcp_component_fn=customize_components,
)
```

## 请求参数处理

FastMCP 智能地处理 OpenAPI 请求中的不同类型参数：

### 查询参数

默认情况下，FastMCP 仅包含具有非空值的查询参数。具有 `None` 值或空字符串的参数会被自动过滤。

```python
# 调用此工具时...
await client.call_tool("search_products", {
    "category": "electronics",  # ✅ 包含
    "min_price": 100,           # ✅ 包含
    "max_price": None,          # ❌ 排除
    "brand": "",                # ❌ 排除
})

# HTTP 请求将是：GET /products?category=electronics&min_price=100
```

### 路径参数

路径参数通常是 REST API 所必需的。FastMCP：
- 过滤 `None` 值
- 验证提供了所有必需的路径参数
- 为缺少的必需参数引发清晰的错误

```python
# ✅ 这有效
await client.call_tool("get_user", {"user_id": 123})

# ❌ 这会引发："缺少必需的路径参数：{'user_id'}"
await client.call_tool("get_user", {"user_id": None})
```

### 数组参数

FastMCP 根据 OpenAPI 规范处理数组参数：

- **查询数组**：根据 `explode` 参数进行序列化（默认：`True`）
- **路径数组**：序列化为逗号分隔值（OpenAPI 'simple' 样式）

```python
# 带有 explode=true 的查询数组（默认）
# ?tags=red&tags=blue&tags=green

# 带有 explode=false 的查询数组
# ?tags=red,blue,green

# 路径数组（始终以逗号分隔）
# /items/red,blue,green
```

### 请求头

请求头参数会自动转换为字符串并包含在 HTTP 请求中。