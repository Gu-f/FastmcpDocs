---
title: oauth_proxy
sidebarTitle: oauth_proxy
---

# `fastmcp.server.auth.oauth_proxy`


FastMCP 的 OAuth 代理提供程序。

此提供程序充当上游 OAuth 授权服务器的透明代理，
在本地处理动态客户端注册的同时转发所有其他 OAuth 流程。
这使得能够与不支持 DCR 或具有
受限客户端注册策略的上游提供商进行身份验证。

主要功能：
- 将授权和令牌端点代理到上游服务器
- 使用固定的上游凭据实现本地动态客户端注册
- 使用上游 JWKS 验证令牌
- 维护最少的本地状态用于记录
- 通过请求关联增强日志记录

此实现基于 OAuth 2.1 规范，专为
企业身份提供商的生产使用而设计。


## 类

### `ProxyDCRClient` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L58" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>


Client for DCR proxy with configurable redirect URI validation.

这个特殊的客户端类对于 OAuth 代理与
动态客户端注册（DCR）正常工作至关重要。它存在的原因如下：

问题：
--------
当 MCP 客户端使用 OAuth 时，它们会使用随机 localhost
端口动态注册（例如，http://localhost:55454/callback）。OAuth 代理需要：
1. Accept these dynamic redirect URIs from clients based on configured patterns
2. 与上游提供商（Google、GitHub 等）使用自己的固定重定向 URI
3. 将授权代码转发回客户端的动态 URI

解决方案：
---------
This class validates redirect URIs against configurable patterns,
同时代理在内部与上游
提供商使用自己的固定重定向 URI。这允许即使客户端使用
不同端口重新连接或缓存令牌时流程仍然有效。

Without proper validation, clients could get "Redirect URI not registered" errors
when trying to authenticate with cached tokens, or security vulnerabilities could
arise from accepting arbitrary redirect URIs.


**方法：**

#### `validate_redirect_uri` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L97" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
validate_redirect_uri(self, redirect_uri: AnyUrl | None) -> AnyUrl
```

Validate redirect URI against allowed patterns.

由于我们充当代理且客户端动态注册，
we validate their redirect URIs against configurable patterns.
This is essential for cached token scenarios where the client may
reconnect with a different port.


### `OAuthProxy` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L123" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>


在代理到非 DCR IdP 的同时展示符合 DCR 的接口的 OAuth 提供程序。

目的
-------
MCP 客户端希望 OAuth 提供程序支持动态客户端注册（DCR），
即客户端可以动态注册自己并接收唯一凭据。
大多数企业 IdP（Google、GitHub、Azure AD 等）不支持 DCR，需要
预先注册的具有固定凭据的 OAuth 应用程序。

此代理通过以下方式弥合这一差距：
- 向 MCP 客户端展示完整的符合 DCR 的 OAuth 接口
- 将 DCR 注册请求转换为使用预配置的上游凭据
- 将所有 OAuth 流程代理到上游 IDP，并进行适当的转换
- 管理两种协议的状态和安全要求

架构概览
--------------------
代理与上游提供商维护单个 OAuth 应用注册，
同时允许无限数量的 MCP 客户端动态注册和身份验证。
它为客户端实现完整的 OAuth 2.1 + DCR 规范，同时
转换为上游提供商所需的任何 OAuth 变体。

解决的关键转换挑战
---------------------------------
1. 动态客户端注册：
   - MCP 客户端希望动态注册并获取唯一凭据
   - 上游 IDP 需要具有固定凭据的预先注册应用
   - 解决方案：接受 DCR 请求，返回共享的上游凭据

2. 动态重定向 URI：
   - MCP 客户端使用在会话间更改的随机 localhost 端口
   - 上游 IDP 需要固定、预先注册的重定向 URI
   - 解决方案：与上游使用代理的固定回调 URL，转发到客户端的动态 URI

3. 授权代码映射：
   - 上游为代理的重定向 URI 返回代码
   - 客户端希望为自己的重定向 URI 获取代码
   - 解决方案：在服务器端交换上游代码，向客户端发放新代码

4. 状态参数冲突：
   - 客户端和代理都需要在整个流程中维护状态
   - OAuth 中只有一个状态参数可用
   - 解决方案：与上游使用事务 ID 作为状态，保留客户端的状态

5. 令牌管理：
   - 客户端可能希望不同于上游提供的令牌格式/声明
   - 需要跟踪令牌以进行撤销和刷新
   - 解决方案：存储令牌关系，透明转发上游令牌

OAuth 流程实现
------------------------
1. 客户端注册（DCR）：
   - 接受任何客户端注册请求
   - 存储接受动态重定向 URI 的 ProxyDCRClient

2. 授权：
   - 存储将客户端详细信息映射到代理流程的事务
   - 使用代理的固定重定向 URI 重定向到上游
   - 与上游使用事务 ID 作为状态参数

3. 上游回调：
   - 交换上游授权代码获取令牌（服务器端）
   - 生成绑定到客户端 PKCE 挑战的新授权代码
   - 重定向到客户端的原始动态重定向 URI

4. 令牌交换：
   - 验证客户端的代码和 PKCE 验证程序
   - 返回之前获取的上游令牌
   - 清理一次性使用的授权代码

5. 令牌刷新：
   - 使用 authlib 将刷新请求转发到上游
   - 处理上游发放新刷新令牌时的令牌轮转
   - 更新本地令牌映射

状态管理
---------------
代理维护最小但至关重要的状态：
- _clients：DCR 注册（所有都使用 ProxyDCRClient 以获得灵活性）
- _oauth_transactions：带有客户端上下文的活跃授权流程
- _client_codes：带有 PKCE 挑战和上游令牌的授权代码
- _access_tokens、_refresh_tokens：用于撤销的令牌存储
- 用于清理和轮转的令牌关系映射

安全考量
----------------------
- 端对端强制执行 PKCE（客户端到代理，代理到上游）
- 授权代码是单次使用的，具有短期过期时间
- 事务 ID 是加密随机的
- 所有状态在使用后都会被清理以防止重放
- 令牌验证委托给上游提供商

提供商兼容性
---------------------
与支持以下功能的任何 OAuth 2.0 提供商兼容：
- 授权代码流程
- 固定重定向 URI（在提供商的应用设置中配置）
- 标准令牌端点

处理提供商特定要求：
- Google：确保最小范围要求
- GitHub：与 OAuth 应用和 GitHub 应用兼容
- Azure AD：处理租户特定的端点
- 通用：与任何符合规范的提供商兼容


**方法：**

#### `get_client` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L368" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
get_client(self, client_id: str) -> OAuthClientInformationFull | None
```

Get client information by ID. This is generally the random ID
provided to the DCR client during registration, not the upstream client ID.

For unregistered clients, returns None (which will raise an error in the SDK).


#### `register_client` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L378" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
register_client(self, client_info: OAuthClientInformationFull) -> None
```

Register a client locally

When a client registers, we create a ProxyDCRClient that is more
forgiving about validating redirect URIs, since the DCR client's
redirect URI will likely be localhost or unknown to the proxied IDP. The
proxied IDP only knows about this server's fixed redirect URI.


#### `authorize` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L421" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
authorize(self, client: OAuthClientInformationFull, params: AuthorizationParams) -> str
```

开始 OAuth 事务并重定向到上游 IdP。

这实现了符合 DCR 的代理模式：
1. 存储包含客户端详细信息和 PKCE 挑战的事务
2. Generate proxy's own PKCE parameters if forwarding is enabled
3. Use transaction ID as state for IdP
4. Redirect to IdP with our fixed callback URL and proxy's PKCE


#### `load_authorization_code` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L504" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
load_authorization_code(self, client: OAuthClientInformationFull, authorization_code: str) -> AuthorizationCode | None
```

加载授权代码进行验证。

查找我们的客户端代码并返回
带有 PKCE 挑战的授权代码对象用于验证。


#### `exchange_authorization_code` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L546" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
exchange_authorization_code(self, client: OAuthClientInformationFull, authorization_code: AuthorizationCode) -> OAuthToken
```

交换授权代码获取存储的 IdP 令牌。

对于符合 DCR 的代理流程，我们返回在
IdP 回调交换期间获得的 IdP 令牌。PKCE 验证由 MCP 框架处理。


#### `load_refresh_token` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L613" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
load_refresh_token(self, client: OAuthClientInformationFull, refresh_token: str) -> RefreshToken | None
```

从本地存储加载刷新令牌。


#### `exchange_refresh_token` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L621" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
exchange_refresh_token(self, client: OAuthClientInformationFull, refresh_token: RefreshToken, scopes: list[str]) -> OAuthToken
```

使用 authlib 交换刷新令牌获取新的访问令牌。


#### `load_access_token` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L697" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
load_access_token(self, token: str) -> AccessToken | None
```

使用上游 JWKS 验证访问令牌。

委托给 JWT 验证器，该验证器使用上游 JWKS 处理签名验证、
过期检查和声明验证。


#### `revoke_token` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L714" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
revoke_token(self, token: AccessToken | RefreshToken) -> None
```

在本地撤销令牌，如果支持的话也在上游服务器撤销。

从本地存储中移除令牌，如果配置了撤销端点，
则尝试在上游服务器上撤销它们。


#### `get_routes` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L758" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
get_routes(self, mcp_path: str | None = None, mcp_endpoint: Any | None = None) -> list[Route]
```

获取带有自定义代理令牌处理程序的 OAuth 路由。

此方法创建标准 OAuth 路由，并将令牌端点替换为
将请求转发到上游 OAuth 服务器的代理处理程序。

**Args:**
- `mcp_path`: The path where the MCP endpoint is mounted (e.g., "/mcp")
- `mcp_endpoint`: The MCP endpoint handler to protect with auth

