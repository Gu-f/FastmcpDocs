---
title: oauth_proxy
sidebarTitle: oauth_proxy
---

# `fastmcp.server.auth.oauth_proxy`


FastMCP 的 OAuth 代理提供程序。

此提供程序充当上游 OAuth 授权服务器的透明代理，
在本地处理动态客户端注册的同时转发所有其他 OAuth 流程。
这使得能够与不支持 DCR 或具有
受限客户端注册策略的上游提供商进行身份验证。

主要功能：
- 将授权和令牌端点代理到上游服务器
- 使用固定的上游凭据实现本地动态客户端注册
- 使用上游 JWKS 验证令牌
- 维护最少的本地状态用于记录
- 通过请求关联增强日志记录

此实现基于 OAuth 2.1 规范，专为
企业身份提供商的生产使用而设计。


## 类

### `ProxyDCRClient` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L54" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>


接受任何 localhost 重定向 URI 的 DCR 代理客户端。

这个特殊的客户端类对于 OAuth 代理与
动态客户端注册（DCR）正常工作至关重要。它存在的原因如下：

问题：
--------
当 MCP 客户端使用 OAuth 时，它们会使用随机 localhost
端口动态注册（例如，http://localhost:55454/callback）。OAuth 代理需要：
1. 接受来自客户端的这些动态重定向 URI
2. 与上游提供商（Google、GitHub 等）使用自己的固定重定向 URI
3. 将授权代码转发回客户端的动态 URI

解决方案：
---------
此类覆盖 redirect_uri 验证以接受任何 localhost URI，
同时代理在内部与上游
提供商使用自己的固定重定向 URI。这允许即使客户端使用
不同端口重新连接或缓存令牌时流程仍然有效。

没有此类，客户端在尝试使用缓存令牌进行身份验证时会遇到“重定向 URI 未注册”错误，
因为存储的客户端
将具有与新动态端口不匹配的固定重定向 URI。


**方法：**

#### `validate_redirect_uri` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L80" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
validate_redirect_uri(self, redirect_uri: AnyUrl | None) -> AnyUrl
```

接受 DCR 客户端的任何 localhost 重定向 URI。

由于我们充当代理且客户端动态注册，
我们需要接受它们的 localhost 重定向 URI，即使它们
在我们这里没有预先注册。对于客户端可能使用不同端口重新连接的缓存令牌
场景，这至关重要。


### `OAuthProxy` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L107" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>


在代理到非 DCR IdP 的同时展示符合 DCR 的接口的 OAuth 提供程序。

目的
-------
MCP 客户端希望 OAuth 提供程序支持动态客户端注册（DCR），
即客户端可以动态注册自己并接收唯一凭据。
大多数企业 IdP（Google、GitHub、Azure AD 等）不支持 DCR，需要
预先注册的具有固定凭据的 OAuth 应用程序。

此代理通过以下方式弥合这一差距：
- 向 MCP 客户端展示完整的符合 DCR 的 OAuth 接口
- 将 DCR 注册请求转换为使用预配置的上游凭据
- 将所有 OAuth 流程代理到上游 IDP，并进行适当的转换
- 管理两种协议的状态和安全要求

架构概览
--------------------
代理与上游提供商维护单个 OAuth 应用注册，
同时允许无限数量的 MCP 客户端动态注册和身份验证。
它为客户端实现完整的 OAuth 2.1 + DCR 规范，同时
转换为上游提供商所需的任何 OAuth 变体。

解决的关键转换挑战
---------------------------------
1. 动态客户端注册：
   - MCP 客户端希望动态注册并获取唯一凭据
   - 上游 IDP 需要具有固定凭据的预先注册应用
   - 解决方案：接受 DCR 请求，返回共享的上游凭据

2. 动态重定向 URI：
   - MCP 客户端使用在会话间更改的随机 localhost 端口
   - 上游 IDP 需要固定、预先注册的重定向 URI
   - 解决方案：与上游使用代理的固定回调 URL，转发到客户端的动态 URI

3. 授权代码映射：
   - 上游为代理的重定向 URI 返回代码
   - 客户端希望为自己的重定向 URI 获取代码
   - 解决方案：在服务器端交换上游代码，向客户端发放新代码

4. 状态参数冲突：
   - 客户端和代理都需要在整个流程中维护状态
   - OAuth 中只有一个状态参数可用
   - 解决方案：与上游使用事务 ID 作为状态，保留客户端的状态

5. 令牌管理：
   - 客户端可能希望不同于上游提供的令牌格式/声明
   - 需要跟踪令牌以进行撤销和刷新
   - 解决方案：存储令牌关系，透明转发上游令牌

OAuth 流程实现
------------------------
1. 客户端注册（DCR）：
   - 接受任何客户端注册请求
   - 存储接受动态重定向 URI 的 ProxyDCRClient
   - 向所有客户端返回共享的上游凭据

2. 授权：
   - 存储将客户端详细信息映射到代理流程的事务
   - 使用代理的固定重定向 URI 重定向到上游
   - 与上游使用事务 ID 作为状态参数

3. 上游回调：
   - 交换上游授权代码获取令牌（服务器端）
   - 生成绑定到客户端 PKCE 挑战的新授权代码
   - 重定向到客户端的原始动态重定向 URI

4. 令牌交换：
   - 验证客户端的代码和 PKCE 验证程序
   - 返回之前获取的上游令牌
   - 清理一次性使用的授权代码

5. 令牌刷新：
   - 使用 authlib 将刷新请求转发到上游
   - 处理上游发放新刷新令牌时的令牌轮转
   - 更新本地令牌映射

状态管理
---------------
代理维护最小但至关重要的状态：
- _clients：DCR 注册（所有都使用 ProxyDCRClient 以获得灵活性）
- _oauth_transactions：带有客户端上下文的活跃授权流程
- _client_codes：带有 PKCE 挑战和上游令牌的授权代码
- _access_tokens、_refresh_tokens：用于撤销的令牌存储
- 用于清理和轮转的令牌关系映射

安全考量
----------------------
- 端对端强制执行 PKCE（客户端到代理，代理到上游）
- 授权代码是单次使用的，具有短期过期时间
- 事务 ID 是加密随机的
- 所有状态在使用后都会被清理以防止重放
- 令牌验证委托给上游提供商

提供商兼容性
---------------------
与支持以下功能的任何 OAuth 2.0 提供商兼容：
- 授权代码流程
- 固定重定向 URI（在提供商的应用设置中配置）
- 标准令牌端点

处理提供商特定要求：
- Google：确保最小范围要求
- GitHub：与 OAuth 应用和 GitHub 应用兼容
- Azure AD：处理租户特定的端点
- 通用：与任何符合规范的提供商兼容


**方法：**

#### `get_client` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L333" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
get_client(self, client_id: str) -> OAuthClientInformationFull | None
```

根据 ID 获取客户端信息。

对于未注册的客户端，返回一个为 DCR 客户端接受
任何 localhost 重定向 URI 的 ProxyDCRClient。

即使是已注册的客户端也使用 ProxyDCRClient 以确保它们能够
在重新连接时使用不同的动态端口进行身份验证。这
处理了具有缓存令牌的客户端在不同端口上重新连接的情况。


#### `register_client` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L364" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
register_client(self, client_info: OAuthClientInformationFull) -> None
```

使用固定的上游凭据在本地注册客户端。

此实现始终使用上游的 client_id 和 client_secret，
无论客户端请求什么。它会就地修改 client_info 对象，
因为 MCP 框架会忽略返回值。

这确保所有客户端都使用在
上游服务器注册的相同凭据。

实现细节：
我们存储 ProxyDCRClient（而不是原始的 client_info）以确保
客户端可以使用不同的动态重定向 URI 重新连接。这对于
客户端端口发生变化的缓存令牌场景至关重要。

流程：
1. 客户端提供其所需的重定向 URI（动态 localhost 端口）
2. 我们创建一个将接受任何 localhost URI 的 ProxyDCRClient
3. 我们存储此灵活的客户端用于未来的身份验证
4. 当客户端使用不同端口重新连接时，ProxyDCRClient 接受它


#### `authorize` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L421" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
authorize(self, client: OAuthClientInformationFull, params: AuthorizationParams) -> str
```

开始 OAuth 事务并重定向到上游 IdP。

这实现了符合 DCR 的代理模式：
1. 存储包含客户端详细信息和 PKCE 挑战的事务
2. 使用事务 ID 作为 IdP 的状态
3. 使用我们的固定回调 URL 重定向到 IdP


#### `load_authorization_code` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L478" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
load_authorization_code(self, client: OAuthClientInformationFull, authorization_code: str) -> AuthorizationCode | None
```

加载授权代码进行验证。

查找我们的客户端代码并返回
带有 PKCE 挑战的授权代码对象用于验证。


#### `exchange_authorization_code` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L520" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
exchange_authorization_code(self, client: OAuthClientInformationFull, authorization_code: AuthorizationCode) -> OAuthToken
```

交换授权代码获取存储的 IdP 令牌。

对于符合 DCR 的代理流程，我们返回在
IdP 回调交换期间获得的 IdP 令牌。PKCE 验证由 MCP 框架处理。


#### `load_refresh_token` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L587" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
load_refresh_token(self, client: OAuthClientInformationFull, refresh_token: str) -> RefreshToken | None
```

从本地存储加载刷新令牌。


#### `exchange_refresh_token` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L595" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
exchange_refresh_token(self, client: OAuthClientInformationFull, refresh_token: RefreshToken, scopes: list[str]) -> OAuthToken
```

使用 authlib 交换刷新令牌获取新的访问令牌。


#### `load_access_token` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L670" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
load_access_token(self, token: str) -> AccessToken | None
```

使用上游 JWKS 验证访问令牌。

委托给 JWT 验证器，该验证器使用上游 JWKS 处理签名验证、
过期检查和声明验证。


#### `revoke_token` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L687" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
revoke_token(self, token: AccessToken | RefreshToken) -> None
```

在本地撤销令牌，如果支持的话也在上游服务器撤销。

从本地存储中移除令牌，如果配置了撤销端点，
则尝试在上游服务器上撤销它们。


#### `get_routes` <sup><a href="https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L880" target="_blank"><Icon icon="github" style="width: 14px; height: 14px;" /></a></sup>

```python
get_routes(self) -> list[Route]
```

获取带有自定义代理令牌处理程序的 OAuth 路由。

此方法创建标准 OAuth 路由，并将令牌端点替换为
将请求转发到上游 OAuth 服务器的代理处理程序。

